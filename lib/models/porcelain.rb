# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal Code generated by protogen. DO NOT EDIT.

module SDM
  class AKS
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSBasicAuth
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccount
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccountUserImpersonation
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSUserImpersonation
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWS
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :healthcheck_region
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_region: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_region = healthcheck_region == nil ? "" : healthcheck_region
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AWSConsole is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class AWSConsole
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :enable_env_variables
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username

    attr_accessor :role_arn

    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :session_expiry

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      enable_env_variables: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      session_expiry: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @enable_env_variables = enable_env_variables == nil ? false : enable_env_variables
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @session_expiry = session_expiry == nil ? 0 : session_expiry
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AWSConsoleStaticKeyPair is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class AWSConsoleStaticKeyPair
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :session_expiry

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      session_expiry: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @session_expiry = session_expiry == nil ? 0 : session_expiry
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :region
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      region: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachments assign an account to a role.
  class AccountAttachment
    # The id of the account of this AccountAttachment.
    attr_accessor :account_id
    # Unique identifier of the AccountAttachment.
    attr_accessor :id
    # The id of the attached role of this AccountAttachment.
    attr_accessor :role_id

    def initialize(
      account_id: nil,
      id: nil,
      role_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentCreateResponse reports how the AccountAttachments were created in the system.
  class AccountAttachmentCreateResponse
    # The created AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentDeleteResponse returns information about a AccountAttachment that was deleted.
  class AccountAttachmentDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentGetResponse returns a requested AccountAttachment.
  class AccountAttachmentGetResponse
    # The requested AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentHistory records the state of an AccountAttachment at a given point in time,
  # where every change (create or delete) to an AccountAttachment produces an
  # AccountAttachmentHistory record.
  class AccountAttachmentHistory
    # The complete AccountAttachment state at this time.
    attr_accessor :account_attachment
    # The unique identifier of the Activity that produced this change to the AccountAttachment.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountAttachment was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountAttachment state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_attachment: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountCreateResponse reports how the Accounts were created in the system.
  class AccountCreateResponse
    # The created Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Account. The Account will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil,
      token: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountDeleteResponse returns information about a Account that was deleted.
  class AccountDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGetResponse returns a requested Account.
  class AccountGetResponse
    # The requested Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrants connect a resource directly to an account, giving the account the permission to connect to that resource.
  class AccountGrant
    # The account ID of this AccountGrant.
    attr_accessor :account_id
    # Unique identifier of the AccountGrant.
    attr_accessor :id
    # The resource ID of this AccountGrant.
    attr_accessor :resource_id
    # The timestamp when the resource will be granted. When creating an AccountGrant, if this field is not specified, it will default to the current time.
    attr_accessor :start_from
    # The timestamp when the resource grant will expire.
    attr_accessor :valid_until

    def initialize(
      account_id: nil,
      id: nil,
      resource_id: nil,
      start_from: nil,
      valid_until: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
      @valid_until = valid_until == nil ? nil : valid_until
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantCreateResponse reports how the AccountGrants were created in the system.
  class AccountGrantCreateResponse
    # The created AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantDeleteResponse returns information about a AccountGrant that was deleted.
  class AccountGrantDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantGetResponse returns a requested AccountGrant.
  class AccountGrantGetResponse
    # The requested AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantHistory records the state of an AccountGrant at a given point in time,
  # where every change (create or delete) to an AccountGrant produces an
  # AccountGrantHistory record.
  class AccountGrantHistory
    # The complete AccountGrant state at this time.
    attr_accessor :account_grant
    # The unique identifier of the Activity that produced this change to the AccountGrant.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountGrant was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountGrant state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_grant: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountHistory records the state of an Account at a given point in time,
  # where every change (create, update and delete) to an Account produces an
  # AccountHistory record.
  class AccountHistory
    # The complete Account state at this time.
    attr_accessor :account
    # The unique identifier of the Activity that produced this change to the Account.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Account was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Account state was recorded.
    attr_accessor :timestamp

    def initialize(
      account: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account = account == nil ? nil : account
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountPermission represents an individual API action available to an account.
  class AccountPermission
    # The unique identifier of the Account this permission belongs to.
    attr_accessor :account_id
    # The most recent time at which the permission was granted. If a permission was
    # granted, revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The value of this permission, split into vertical and action e.g.
    # 'secretstore:List', 'role:update'
    attr_accessor :permission
    # The scope of this permission. A global scope means this action can be taken
    # on any entity; otherwise the action can only be taken on or in the scope of
    # the scoped id.
    attr_accessor :scope
    # The ID to which or in whose context this operation is permitted. e.g. The ID of a
    # role that a team leader has the abillity to remove and add accounts to, or the
    # ID of a resource that a user has the permission to connect to. If Scope is global,
    # scoped id is not populated.
    attr_accessor :scoped_id

    def initialize(
      account_id: nil,
      granted_at: nil,
      permission: nil,
      scope: nil,
      scoped_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @granted_at = granted_at == nil ? nil : granted_at
      @permission = permission == nil ? "" : permission
      @scope = scope == nil ? "" : scope
      @scoped_id = scoped_id == nil ? "" : scoped_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountResource represents an individual access grant of a Account to a Resource.
  class AccountResource
    # The unique identifier of the AccountGrant through which the Account was granted access to the Resource.
    # If empty, access was not granted through an AccountGrant.
    attr_accessor :account_grant_id
    # The unique identifier of the Account to which access is granted.
    attr_accessor :account_id
    # The time this grant was created, distinct from 'granted at' in the case where access is scheduled
    # for the future. If access was granted, revoked, and granted again, this will reflect the later creation time.
    attr_accessor :created_at
    # The time at which access will expire. If empty, this access has no expiration.
    attr_accessor :expires_at
    # The most recent time at which access was granted. If access was granted,
    # revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The unique identifier of the Resource to which access is granted.
    attr_accessor :resource_id
    # The unique identifier of the Role through which the Account was granted access to the Resource.
    # If empty, access was not granted through an AccountAttachment to a Role.
    attr_accessor :role_id

    def initialize(
      account_grant_id: nil,
      account_id: nil,
      created_at: nil,
      expires_at: nil,
      granted_at: nil,
      resource_id: nil,
      role_id: nil
    )
      @account_grant_id = account_grant_id == nil ? "" : account_grant_id
      @account_id = account_id == nil ? "" : account_id
      @created_at = created_at == nil ? nil : created_at
      @expires_at = expires_at == nil ? nil : expires_at
      @granted_at = granted_at == nil ? nil : granted_at
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountResourceHistory records the state of a AccountResource at a given point in time,
  # where every change (create or delete) to a AccountResource produces an
  # AccountResourceHistory record.
  class AccountResourceHistory
    # The complete AccountResource state at this time.
    attr_accessor :account_resource
    # The unique identifier of the Activity that produced this change to the AccountResource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountResource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountResource state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_resource: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_resource = account_resource == nil ? nil : account_resource
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountUpdateResponse returns the fields of a Account after it has been updated by
  # a AccountUpdateRequest.
  class AccountUpdateResponse
    # The updated Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # An Activity is a record of an action taken against a strongDM deployment, e.g.
  # a user creation, resource deletion, sso configuration change, etc.
  class Activity
    # The account who executed this activity. If the actor later has a name or email change,
    # that change is not reflected here. Actor is a snapshot of the executing account at
    # the time an activity took place.
    attr_accessor :actor
    # The time this activity took effect.
    attr_accessor :completed_at
    # A humanized description of the activity.
    attr_accessor :description
    # The entities involved in this activity. These entities can be any first class
    # entity in the strongDM system, eg. a user, a role, a node, an account grant. Not
    # every activity affects explicit entities.
    attr_accessor :entities
    # Unique identifier of the Activity.
    attr_accessor :id
    # The IP from which this action was taken.
    attr_accessor :ip_address
    # The kind of activity which has taken place.
    attr_accessor :verb

    def initialize(
      actor: nil,
      completed_at: nil,
      description: nil,
      entities: nil,
      id: nil,
      ip_address: nil,
      verb: nil
    )
      @actor = actor == nil ? nil : actor
      @completed_at = completed_at == nil ? nil : completed_at
      @description = description == nil ? "" : description
      @entities = entities == nil ? [] : entities
      @id = id == nil ? "" : id
      @ip_address = ip_address == nil ? "" : ip_address
      @verb = verb == nil ? "" : verb
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActivityActor
    # The external ID of the actor at the time this activity occurred.
    attr_accessor :activity_external_id
    # The email of the actor at the time this activity occurred.
    attr_accessor :email
    # The first name of the actor at the time this activity occurred.
    attr_accessor :first_name
    # Unique identifier of the actor. Immutable.
    attr_accessor :id
    # The last name of the actor at the time this activity occurred.
    attr_accessor :last_name

    def initialize(
      activity_external_id: nil,
      email: nil,
      first_name: nil,
      id: nil,
      last_name: nil
    )
      @activity_external_id = activity_external_id == nil ? "" : activity_external_id
      @email = email == nil ? "" : email
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActivityEntity
    # The email of the affected entity, if it has one (for example, if it is an account).
    attr_accessor :email
    # The external ID of the affected entity, if it has one (for example, if it is an account).
    attr_accessor :external_id
    # The unique identifier of the entity this activity affected.
    attr_accessor :id
    # A display name representing the affected entity.
    attr_accessor :name
    # The type of entity affected, one of the Activity Entities constants.
    attr_accessor :type

    def initialize(
      email: nil,
      external_id: nil,
      id: nil,
      name: nil,
      type: nil
    )
      @email = email == nil ? "" : email
      @external_id = external_id == nil ? "" : external_id
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @type = type == nil ? "" : type
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ActivityGetResponse returns a requested Activity.
  class ActivityGetResponse
    # The requested Activity.
    attr_accessor :activity
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      activity: nil,
      meta: nil,
      rate_limit: nil
    )
      @activity = activity == nil ? nil : activity
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKS
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSInstanceProfile
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username

    attr_accessor :role_arn

    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSInstanceProfileUserImpersonation
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username

    attr_accessor :role_arn

    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSUserImpersonation
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonES
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonMQAMQP091
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Athena
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :output

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      output: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @output = output == nil ? "" : output
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraMysql
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraPostgres
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Azure
    attr_accessor :app_id
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureCertificate
    attr_accessor :app_id
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :client_certificate
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      bind_interface: nil,
      client_certificate: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureMysql
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzurePostgres
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :vault_uri

    def initialize(
      id: nil,
      name: nil,
      tags: nil,
      vault_uri: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @vault_uri = vault_uri == nil ? "" : vault_uri
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class BigQuery
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :private_key

    attr_accessor :project
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      private_key: nil,
      project: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @project = project == nil ? "" : project
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cassandra
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Citus
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Clustrix
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cockroach
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelGetSSHCAPublicKeyResponse represents a request for an
  # organization's SSH Certificate Authority public key.
  class ControlPanelGetSSHCAPublicKeyResponse
    # Reserved for future use.
    attr_accessor :meta
    # The public key of the SSH Certificate Authority, in OpenSSH RSA public
    # key format.
    attr_accessor :public_key
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      public_key: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @public_key = public_key == nil ? "" : public_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelVerifyJWTResponse reports whether x-sdm-token is valid.
  class ControlPanelVerifyJWTResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # Reports if the given token is valid.
    attr_accessor :valid

    def initialize(
      meta: nil,
      rate_limit: nil,
      valid: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @valid = valid == nil ? false : valid
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CreateResponseMetadata is reserved for future use.
  class CreateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CyberarkConjurStore
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CyberarkPAMExperimentalStore is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class CyberarkPAMExperimentalStore
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CyberarkPAMStore
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2I
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2LUW
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # DeleteResponseMetadata is reserved for future use.
  class DeleteResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DelineaStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :server_url
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tenant_name

    def initialize(
      id: nil,
      name: nil,
      server_url: nil,
      tags: nil,
      tenant_name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @server_url = server_url == nil ? "" : server_url
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_name = tenant_name == nil ? "" : tenant_name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBHost
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBReplicaSet
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Druid
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DynamoDB
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Elastic
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ElasticacheRedis
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCP
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id

    attr_accessor :keyfile
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :scopes
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      keyfile: nil,
      name: nil,
      port_override: nil,
      scopes: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @keyfile = keyfile == nil ? "" : keyfile
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @scopes = scopes == nil ? "" : scopes
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCPStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :projectid
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      projectid: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @projectid = projectid == nil ? "" : projectid
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Gateway represents a StrongDM CLI installation running in gateway mode.
  class Gateway
    # The hostname/port tuple which the gateway daemon will bind to.
    # If not provided on create, set to "0.0.0.0:listen_address_port".
    attr_accessor :bind_address
    # Device is a read only device name uploaded by the gateway process when
    # it comes online.
    attr_accessor :device
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways.
    attr_accessor :gateway_filter
    # Unique identifier of the Gateway.
    attr_accessor :id
    # The public hostname/port tuple at which the gateway will be accessible to clients.
    attr_accessor :listen_address
    # Location is a read only network location uploaded by the gateway process
    # when it comes online.
    attr_accessor :location
    # Unique human-readable name of the Gateway. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the gateway. One of: "new", "verifying_restart",
    # "restarting", "started", "stopped", "dead", "unknown"
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # Version is a read only sdm binary version uploaded by the gateway process
    # when it comes online.
    attr_accessor :version

    def initialize(
      bind_address: nil,
      device: nil,
      gateway_filter: nil,
      id: nil,
      listen_address: nil,
      location: nil,
      name: nil,
      state: nil,
      tags: nil,
      version: nil
    )
      @bind_address = bind_address == nil ? "" : bind_address
      @device = device == nil ? "" : device
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @listen_address = listen_address == nil ? "" : listen_address
      @location = location == nil ? "" : location
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @version = version == nil ? "" : version
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # GetResponseMetadata is reserved for future use.
  class GetResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKE
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :service_account_key
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      service_account_key: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKEUserImpersonation
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :service_account_key
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      service_account_key: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Greenplum
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPAuth
    attr_accessor :auth_header
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :headers_blacklist

    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :url

    def initialize(
      auth_header: nil,
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @auth_header = auth_header == nil ? "" : auth_header
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPBasicAuth
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :headers_blacklist

    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :url

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      password: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPNoAuth
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :headers_blacklist

    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :url

    def initialize(
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Kubernetes
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesBasicAuth
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccount
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccountUserImpersonation
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesUserImpersonation
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MTLSMysql is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MTLSMysql
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :server_name
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      server_name: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MTLSPostgres
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :server_name
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      server_name: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Maria
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memcached
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memsql
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoHost is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoHost
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoLegacyHost
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoLegacyReplicaset
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoReplicaSet is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoReplicaSet
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoShardedCluster is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoShardedCluster
    attr_accessor :auth_database
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Mysql
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Neptune
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class NeptuneIAM
    attr_accessor :access_key
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeCreateResponse reports how the Nodes were created in the system.
  class NodeCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Node. The Node will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil,
      token: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeDeleteResponse returns information about a Node that was deleted.
  class NodeDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeGetResponse returns a requested Node.
  class NodeGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeHistory records the state of a Node at a given point in time,
  # where every change (create, update and delete) to a Node produces an
  # NodeHistory record.
  class NodeHistory
    # The unique identifier of the Activity that produced this change to the Node.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Node was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Node state at this time.
    attr_accessor :node
    # The time at which the Node state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      node: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @node = node == nil ? nil : node
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeUpdateResponse returns the fields of a Node after it has been updated by
  # a NodeUpdateRequest.
  class NodeUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The updated Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Oracle
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Organization
    # The Organization's authentication provider.
    attr_accessor :auth_provider
    # The time at which the Organization was created.
    attr_accessor :created_at
    # The Organization's idle timeout, if enabled.
    attr_accessor :idle_timeout
    # Indicates if the Organization has idle timeouts enabled.
    attr_accessor :idle_timeout_enabled
    # The Organization's type.
    attr_accessor :kind
    # The Organization's local log encryption encoder.
    attr_accessor :log_local_encoder
    # The Organization's local log format.
    attr_accessor :log_local_format
    # The Organization's local log storage.
    attr_accessor :log_local_storage
    # The Organization's remote log encryption encoder.
    attr_accessor :log_remote_encoder
    # The Organization's socket path for Socket local log storage.
    attr_accessor :log_socket_path
    # The Organization's TCP address for TCP or Syslog local log storage.
    attr_accessor :log_tcp_address
    # Indicates if the Organization has multi-factor authentication enabled.
    attr_accessor :mfa_enabled
    # The Organization's multi-factor authentication provider, if enabled.
    attr_accessor :mfa_provider
    # The Organization's name.
    attr_accessor :name
    # Indicates if the Organization requires secret stores.
    attr_accessor :require_secret_store
    # The Organization's URL for SAML metadata.
    attr_accessor :saml_metadata_url
    # The Organization's SCIM provider.
    attr_accessor :scim_provider
    # The Organization's label for sensitive resources.
    attr_accessor :sensitive_label
    # The Organization's session timeout, if enabled.
    attr_accessor :session_timeout
    # Indicates if the Organization has session timeouts enabled.
    attr_accessor :session_timeout_enabled
    # The Organization's SSH certificate authority public key.
    attr_accessor :ssh_certificate_authority_public_key
    # The time at which the Organization's SSH certificate authority was last updated.
    attr_accessor :ssh_certificate_authority_updated_at
    # The time at which the Organization was last updated.
    attr_accessor :updated_at
    # The Organization's web site domain.
    attr_accessor :websites_subdomain

    def initialize(
      auth_provider: nil,
      created_at: nil,
      idle_timeout: nil,
      idle_timeout_enabled: nil,
      kind: nil,
      log_local_encoder: nil,
      log_local_format: nil,
      log_local_storage: nil,
      log_remote_encoder: nil,
      log_socket_path: nil,
      log_tcp_address: nil,
      mfa_enabled: nil,
      mfa_provider: nil,
      name: nil,
      require_secret_store: nil,
      saml_metadata_url: nil,
      scim_provider: nil,
      sensitive_label: nil,
      session_timeout: nil,
      session_timeout_enabled: nil,
      ssh_certificate_authority_public_key: nil,
      ssh_certificate_authority_updated_at: nil,
      updated_at: nil,
      websites_subdomain: nil
    )
      @auth_provider = auth_provider == nil ? "" : auth_provider
      @created_at = created_at == nil ? nil : created_at
      @idle_timeout = idle_timeout == nil ? nil : idle_timeout
      @idle_timeout_enabled = idle_timeout_enabled == nil ? false : idle_timeout_enabled
      @kind = kind == nil ? "" : kind
      @log_local_encoder = log_local_encoder == nil ? "" : log_local_encoder
      @log_local_format = log_local_format == nil ? "" : log_local_format
      @log_local_storage = log_local_storage == nil ? "" : log_local_storage
      @log_remote_encoder = log_remote_encoder == nil ? "" : log_remote_encoder
      @log_socket_path = log_socket_path == nil ? "" : log_socket_path
      @log_tcp_address = log_tcp_address == nil ? "" : log_tcp_address
      @mfa_enabled = mfa_enabled == nil ? false : mfa_enabled
      @mfa_provider = mfa_provider == nil ? "" : mfa_provider
      @name = name == nil ? "" : name
      @require_secret_store = require_secret_store == nil ? false : require_secret_store
      @saml_metadata_url = saml_metadata_url == nil ? "" : saml_metadata_url
      @scim_provider = scim_provider == nil ? "" : scim_provider
      @sensitive_label = sensitive_label == nil ? "" : sensitive_label
      @session_timeout = session_timeout == nil ? nil : session_timeout
      @session_timeout_enabled = session_timeout_enabled == nil ? false : session_timeout_enabled
      @ssh_certificate_authority_public_key = ssh_certificate_authority_public_key == nil ? "" : ssh_certificate_authority_public_key
      @ssh_certificate_authority_updated_at = ssh_certificate_authority_updated_at == nil ? nil : ssh_certificate_authority_updated_at
      @updated_at = updated_at == nil ? nil : updated_at
      @websites_subdomain = websites_subdomain == nil ? "" : websites_subdomain
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # OrganizationHistoryRecord records the state of an Organization at a given point in time,
  # where every change to an Organization produces an OrganizationHistoryRecord.
  class OrganizationHistoryRecord
    # The unique identifier of the Activity that produced this change to the Organization.
    # May be empty for some system-initiated organization updates.
    attr_accessor :activity_id
    # The complete Organization state at this time.
    attr_accessor :organization
    # The time at which the Organization state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      organization: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @organization = organization == nil ? nil : organization
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Postgres
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Presto
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Query is a record of a single client request to a resource, such as a SQL query.
  # Longer-running queries including long-running SSH commands and SSH, RDP, or Kubernetes
  # interactive sessions will return two Query records with the same identifier, one record
  # at the start of the query and a second record upon the completion of the query with
  # additional detail.
  class Query
    # The email of the account performing this query, at the time the query was executed.
    # If the account email is later changed, that change will not be reflected via this field.
    attr_accessor :account_email
    # The given name of the account performing this query, at the time the query was executed.
    # If the account is later renamed, that change will not be reflected via this field.
    attr_accessor :account_first_name
    # Unique identifier of the Account that performed the Query.
    attr_accessor :account_id
    # The family name of the account performing this query, at the time the query was executed.
    # If the account is later renamed, that change will not be reflected via this field.
    attr_accessor :account_last_name
    # The tags of the account accessed, at the time the query was executed. If the account
    # tags are later changed, that change will not be reflected via this field.
    attr_accessor :account_tags
    # For queries against SSH, Kubernetes, and RDP resources, this contains additional information
    # about the captured query.
    attr_accessor :capture
    # The time at which the Query was completed.
    # Empty if this record indicates the start of a long-running query.
    attr_accessor :completed_at
    # The duration of the Query.
    attr_accessor :duration
    # The unique ID of the node through which the Resource was accessed.
    attr_accessor :egress_node_id
    # Indicates that the body of the Query is encrypted.
    attr_accessor :encrypted
    # Unique identifier of the Query.
    attr_accessor :id
    # The captured content of the Query.
    # For queries against SSH, Kubernetes, and RDP resources, this contains a JSON representation of the QueryCapture.
    attr_accessor :query_body
    # The general category of Resource against which Query was performed, e.g. "web" or "cloud".
    attr_accessor :query_category
    # The hash of the body of the Query.
    attr_accessor :query_hash
    # The symmetric key used to encrypt the body of this Query and its replay if replayable.
    # If the Query is encrypted, this field contains an encrypted symmetric key in base64 encoding.
    # This key must be decrypted with the organization's private key to obtain the symmetric key needed to decrypt the body.
    # If the Query is not encrypted, this field is empty.
    attr_accessor :query_key
    # The number of records returned by the Query, for a database Resource.
    attr_accessor :record_count
    # The username of the RemoteIdentity used to access the Resource.
    attr_accessor :remote_identity_username
    # Indicates that the Query is replayable, e.g. for some SSH or K8s sessions.
    attr_accessor :replayable
    # Unique identifier of the Resource against which the Query was performed.
    attr_accessor :resource_id
    # The name of the resource accessed, at the time the query was executed. If the resource
    # is later renamed, that change will not be reflected via this field.
    attr_accessor :resource_name
    # The tags of the resource accessed, at the time the query was executed. If the resource
    # tags are later changed, that change will not be reflected via this field.
    attr_accessor :resource_tags
    # The specific type of Resource against which the Query was performed, e.g. "ssh" or "postgres".
    attr_accessor :resource_type
    # The time at which the Query was started.
    attr_accessor :timestamp

    def initialize(
      account_email: nil,
      account_first_name: nil,
      account_id: nil,
      account_last_name: nil,
      account_tags: nil,
      capture: nil,
      completed_at: nil,
      duration: nil,
      egress_node_id: nil,
      encrypted: nil,
      id: nil,
      query_body: nil,
      query_category: nil,
      query_hash: nil,
      query_key: nil,
      record_count: nil,
      remote_identity_username: nil,
      replayable: nil,
      resource_id: nil,
      resource_name: nil,
      resource_tags: nil,
      resource_type: nil,
      timestamp: nil
    )
      @account_email = account_email == nil ? "" : account_email
      @account_first_name = account_first_name == nil ? "" : account_first_name
      @account_id = account_id == nil ? "" : account_id
      @account_last_name = account_last_name == nil ? "" : account_last_name
      @account_tags = account_tags == nil ? SDM::_porcelain_zero_value_tags() : account_tags
      @capture = capture == nil ? nil : capture
      @completed_at = completed_at == nil ? nil : completed_at
      @duration = duration == nil ? nil : duration
      @egress_node_id = egress_node_id == nil ? "" : egress_node_id
      @encrypted = encrypted == nil ? false : encrypted
      @id = id == nil ? "" : id
      @query_body = query_body == nil ? "" : query_body
      @query_category = query_category == nil ? "" : query_category
      @query_hash = query_hash == nil ? "" : query_hash
      @query_key = query_key == nil ? "" : query_key
      @record_count = record_count == nil ? 0 : record_count
      @remote_identity_username = remote_identity_username == nil ? "" : remote_identity_username
      @replayable = replayable == nil ? false : replayable
      @resource_id = resource_id == nil ? "" : resource_id
      @resource_name = resource_name == nil ? "" : resource_name
      @resource_tags = resource_tags == nil ? SDM::_porcelain_zero_value_tags() : resource_tags
      @resource_type = resource_type == nil ? "" : resource_type
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A QueryCapture contains additional information about queries against SSH, Kubernetes, and RDP resources.
  class QueryCapture
    # The command executed on the client for a Kubernetes session.
    attr_accessor :client_command
    # The command executed over an SSH or Kubernetes session.
    attr_accessor :command
    # The target container of a Kubernetes operation.
    attr_accessor :container
    # The environment variables for an SSH or Kubernetes session.
    attr_accessor :env
    # The remote file name of an SCP operation.
    attr_accessor :file_name
    # The file size transferred for an SCP operation.
    attr_accessor :file_size
    # The height of the terminal or window for SSH, Kubernetes, and RDP interactive sessions.
    attr_accessor :height
    # The target pod of a Kubernetes operation.
    attr_accessor :pod
    # The HTTP request body of a Kubernetes operation.
    attr_accessor :request_body
    # The HTTP request method of a Kubernetes operation.
    attr_accessor :request_method
    # The HTTP request URI of a Kubernetes operation.
    attr_accessor :request_uri
    # The CaptureType of this query capture.
    attr_accessor :type
    # The width of the terminal or window for SSH, Kubernetes, and RDP interactive sessions.
    attr_accessor :width

    def initialize(
      client_command: nil,
      command: nil,
      container: nil,
      env: nil,
      file_name: nil,
      file_size: nil,
      height: nil,
      pod: nil,
      request_body: nil,
      request_method: nil,
      request_uri: nil,
      type: nil,
      width: nil
    )
      @client_command = client_command == nil ? "" : client_command
      @command = command == nil ? "" : command
      @container = container == nil ? "" : container
      @env = env == nil ? {} : env
      @file_name = file_name == nil ? "" : file_name
      @file_size = file_size == nil ? 0 : file_size
      @height = height == nil ? 0 : height
      @pod = pod == nil ? "" : pod
      @request_body = request_body == nil ? "" : request_body
      @request_method = request_method == nil ? "" : request_method
      @request_uri = request_uri == nil ? "" : request_uri
      @type = type == nil ? "" : type
      @width = width == nil ? 0 : width
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RDP
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :downgrade_nla_connections
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      downgrade_nla_connections: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @downgrade_nla_connections = downgrade_nla_connections == nil ? false : downgrade_nla_connections
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RabbitMQAMQP091
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RateLimitMetadata contains information about remaining requests avaialable
  # to the user over some timeframe.
  class RateLimitMetadata
    # The bucket this user/token is associated with, which may be shared between
    # multiple users/tokens.
    attr_accessor :bucket
    # How many total requests the user/token is authorized to make before being
    # rate limited.
    attr_accessor :limit
    # How many remaining requests out of the limit are still avaialable.
    attr_accessor :remaining
    # The time when remaining will be reset to limit.
    attr_accessor :reset_at

    def initialize(
      bucket: nil,
      limit: nil,
      remaining: nil,
      reset_at: nil
    )
      @bucket = bucket == nil ? "" : bucket
      @limit = limit == nil ? 0 : limit
      @remaining = remaining == nil ? 0 : remaining
      @reset_at = reset_at == nil ? nil : reset_at
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RawTCP
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redis
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redshift
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Relay represents a StrongDM CLI installation running in relay mode.
  class Relay
    # Device is a read only device name uploaded by the gateway process when
    # it comes online.
    attr_accessor :device
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways.
    attr_accessor :gateway_filter
    # Unique identifier of the Relay.
    attr_accessor :id
    # Location is a read only network location uploaded by the gateway process
    # when it comes online.
    attr_accessor :location
    # Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the relay. One of: "new", "verifying_restart",
    # "awaiting_restart", "restarting", "started", "stopped", "dead",
    # "unknown".
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # Version is a read only sdm binary version uploaded by the gateway process
    # when it comes online.
    attr_accessor :version

    def initialize(
      device: nil,
      gateway_filter: nil,
      id: nil,
      location: nil,
      name: nil,
      state: nil,
      tags: nil,
      version: nil
    )
      @device = device == nil ? "" : device
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @location = location == nil ? "" : location
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @version = version == nil ? "" : version
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentities define the username to be used for a specific account
  # when connecting to a remote resource using that group.
  class RemoteIdentity
    # The account for this remote identity.
    attr_accessor :account_id
    # Unique identifier of the RemoteIdentity.
    attr_accessor :id
    # The remote identity group.
    attr_accessor :remote_identity_group_id
    # The username to be used as the remote identity for this account.
    attr_accessor :username

    def initialize(
      account_id: nil,
      id: nil,
      remote_identity_group_id: nil,
      username: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityCreateResponse reports how the RemoteIdentities were created in the system.
  class RemoteIdentityCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityDeleteResponse returns information about a RemoteIdentity that was deleted.
  class RemoteIdentityDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGetResponse returns a requested RemoteIdentity.
  class RemoteIdentityGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A RemoteIdentityGroup defines a group of remote identities.
  class RemoteIdentityGroup
    # Unique identifier of the RemoteIdentityGroup.
    attr_accessor :id
    # Unique human-readable name of the RemoteIdentityGroup.
    attr_accessor :name

    def initialize(
      id: nil,
      name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGroupGetResponse returns a requested RemoteIdentityGroup.
  class RemoteIdentityGroupGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RemoteIdentityGroup.
    attr_accessor :remote_identity_group

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity_group: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity_group = remote_identity_group == nil ? nil : remote_identity_group
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGroupHistory records the state of a RemoteIdentityGroup at a given point in time,
  # where every change (create, update and delete) to a RemoteIdentityGroup produces an
  # RemoteIdentityGroupHistory record.
  class RemoteIdentityGroupHistory
    # The unique identifier of the Activity that produced this change to the RemoteIdentityGroup.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RemoteIdentityGroup was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RemoteIdentityGroup state at this time.
    attr_accessor :remote_identity_group
    # The time at which the RemoteIdentityGroup state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      remote_identity_group: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @remote_identity_group = remote_identity_group == nil ? nil : remote_identity_group
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityHistory records the state of a RemoteIdentity at a given point in time,
  # where every change (create, update and delete) to a RemoteIdentity produces an
  # RemoteIdentityHistory record.
  class RemoteIdentityHistory
    # The unique identifier of the Activity that produced this change to the RemoteIdentity.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RemoteIdentity was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RemoteIdentity state at this time.
    attr_accessor :remote_identity
    # The time at which the RemoteIdentity state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      remote_identity: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @remote_identity = remote_identity == nil ? nil : remote_identity
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityUpdateResponse returns the fields of a RemoteIdentity after it has been updated by
  # a RemoteIdentityUpdateRequest.
  class RemoteIdentityUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A ReplayChunk represents a single "chunk" of data from the query replay.
  class ReplayChunk
    # The raw data of the ReplayChunk. The data is encrypted if the associated Query is encrypted.
    attr_accessor :data
    # The list of events of the ReplayChunk. If the Query is encrypted, this field is always empty
    # and the events can be obtained by decrypting the data using the QueryKey returned with the Query.
    attr_accessor :events

    def initialize(
      data: nil,
      events: nil
    )
      @data = data == nil ? "" : data
      @events = events == nil ? [] : events
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A ReplayChunkEvent represents a single event within a query replay.
  # The timing information included in each ReplayChunkEvent may be used to replay a session in real time.
  class ReplayChunkEvent
    # The raw data of the ReplayChunkEvent.
    attr_accessor :data
    # The time duration over which the data in this ReplayChunkEvent was transferred.
    attr_accessor :duration

    def initialize(
      data: nil,
      duration: nil
    )
      @data = data == nil ? "" : data
      @duration = duration == nil ? nil : duration
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceCreateResponse reports how the Resources were created in the system.
  class ResourceCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceDeleteResponse returns information about a Resource that was deleted.
  class ResourceDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceGetResponse returns a requested Resource.
  class ResourceGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceHistory records the state of a Resource at a given point in time,
  # where every change (create, update and delete) to a Resource produces an
  # ResourceHistory record.
  class ResourceHistory
    # The unique identifier of the Activity that produced this change to the Resource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Resource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Resource state at this time.
    attr_accessor :resource
    # The time at which the Resource state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      resource: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @resource = resource == nil ? nil : resource
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceUpdateResponse returns the fields of a Resource after it has been updated by
  # a ResourceUpdateRequest.
  class ResourceUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Role has a list of access rules which determine which Resources the members
  # of the Role have access to. An Account can be a member of multiple Roles via
  # AccountAttachments.
  class Role
    # AccessRules is a list of access rules defining the resources this Role has access to.
    attr_accessor :access_rules
    # Unique identifier of the Role.
    attr_accessor :id
    # Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
    attr_accessor :managed_by
    # Unique human-readable name of the Role.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_rules: nil,
      id: nil,
      managed_by: nil,
      name: nil,
      tags: nil
    )
      @access_rules = access_rules == nil ? SDM::_porcelain_zero_value_access_rules() : access_rules
      @id = id == nil ? "" : id
      @managed_by = managed_by == nil ? "" : managed_by
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleCreateResponse reports how the Roles were created in the system. It can
  # communicate partial successes or failures.
  class RoleCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleDeleteResponse returns information about a Role that was deleted.
  class RoleDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGetResponse returns a requested Role.
  class RoleGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleHistory records the state of a Role at a given point in time,
  # where every change (create, update and delete) to a Role produces an
  # RoleHistory record.
  class RoleHistory
    # The unique identifier of the Activity that produced this change to the Role.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Role was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Role state at this time.
    attr_accessor :role
    # The time at which the Role state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      role: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @role = role == nil ? nil : role
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleResource represents an individual access grant of a Role to a Resource.
  class RoleResource
    # The most recent time at which access was granted. If access was granted,
    # revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The unique identifier of the Resource to which access is granted.
    attr_accessor :resource_id
    # The unique identifier of the Role to which access is granted.
    attr_accessor :role_id

    def initialize(
      granted_at: nil,
      resource_id: nil,
      role_id: nil
    )
      @granted_at = granted_at == nil ? nil : granted_at
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleResourceHistory records the state of a RoleResource at a given point in time,
  # where every change (create or delete) to a RoleResource produces an
  # RoleResourceHistory record.
  class RoleResourceHistory
    # The unique identifier of the Activity that produced this change to the RoleResource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RoleResource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RoleResource state at this time.
    attr_accessor :role_resource
    # The time at which the RoleResource state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      role_resource: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @role_resource = role_resource == nil ? nil : role_resource
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleUpdateResponse returns the fields of a Role after it has been updated by
  # a RoleUpdateRequest.
  class RoleUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServer
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      schema: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSH
    attr_accessor :allow_deprecated_key_exchanges
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id

    attr_accessor :key_type
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_forwarding

    attr_accessor :port_override

    attr_accessor :public_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      key_type: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      public_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @key_type = key_type == nil ? "" : key_type
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @public_key = public_key == nil ? "" : public_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCert
    attr_accessor :allow_deprecated_key_exchanges
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id

    attr_accessor :key_type
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_forwarding

    attr_accessor :port_override

    attr_accessor :remote_identity_group_id

    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      key_type: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @key_type = key_type == nil ? "" : key_type
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCustomerKey
    attr_accessor :allow_deprecated_key_exchanges
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_forwarding

    attr_accessor :port_override

    attr_accessor :private_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      private_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreCreateResponse reports how the SecretStores were created in the system.
  class SecretStoreCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreDeleteResponse returns information about a SecretStore that was deleted.
  class SecretStoreDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreGetResponse returns a requested SecretStore.
  class SecretStoreGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreHistory records the state of a SecretStore at a given point in time,
  # where every change (create, update and delete) to a SecretStore produces an
  # SecretStoreHistory record.
  class SecretStoreHistory
    # The unique identifier of the Activity that produced this change to the SecretStore.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this SecretStore was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete SecretStore state at this time.
    attr_accessor :secret_store
    # The time at which the SecretStore state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      secret_store: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @secret_store = secret_store == nil ? nil : secret_store
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreUpdateResponse returns the fields of a SecretStore after it has been updated by
  # a SecretStoreUpdateRequest.
  class SecretStoreUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Service is a service account that can connect to resources they are granted
  # directly, or granted via roles. Services are typically automated jobs.
  class Service
    # Unique identifier of the Service.
    attr_accessor :id
    # Unique human-readable name of the Service.
    attr_accessor :name
    # The Service's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      suspended: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SingleStore
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Snowflake
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override

    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      schema: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Snowsight is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class Snowsight
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :healthcheck_username
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :samlmetadata
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_username: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      samlmetadata: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_username = healthcheck_username == nil ? "" : healthcheck_username
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @samlmetadata = samlmetadata == nil ? "" : samlmetadata
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Sybase
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SybaseIQ
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Tag
    attr_accessor :name

    attr_accessor :value

    def initialize(
      name: nil,
      value: nil
    )
      @name = name == nil ? "" : name
      @value = value == nil ? "" : value
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Teradata
    # Bind interface
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Trino is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class Trino
    # Bind interface
    attr_accessor :bind_interface

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # UpdateResponseMetadata is reserved for future use.
  class UpdateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A User can connect to resources they are granted directly, or granted
  # via roles.
  class User
    # The User's email address. Must be unique.
    attr_accessor :email
    # External ID is an alternative unique ID this user is represented by within an external service.
    attr_accessor :external_id
    # The User's first name.
    attr_accessor :first_name
    # Unique identifier of the User.
    attr_accessor :id
    # The User's last name.
    attr_accessor :last_name
    # Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
    attr_accessor :managed_by
    # PermissionLevel is a read only field for the user's permission level e.g. admin, DBA, user.
    attr_accessor :permission_level
    # The User's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      email: nil,
      external_id: nil,
      first_name: nil,
      id: nil,
      last_name: nil,
      managed_by: nil,
      permission_level: nil,
      suspended: nil,
      tags: nil
    )
      @email = email == nil ? "" : email
      @external_id = external_id == nil ? "" : external_id
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
      @managed_by = managed_by == nil ? "" : managed_by
      @permission_level = permission_level == nil ? "" : permission_level
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultAppRoleStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :namespace

    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTLSStore
    attr_accessor :ca_cert_path

    attr_accessor :client_cert_path

    attr_accessor :client_key_path
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :namespace

    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_cert_path: nil,
      client_cert_path: nil,
      client_key_path: nil,
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @ca_cert_path = ca_cert_path == nil ? "" : ca_cert_path
      @client_cert_path = client_cert_path == nil ? "" : client_cert_path
      @client_key_path = client_key_path == nil ? "" : client_key_path
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTokenStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :namespace

    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # @private
  def self._porcelain_zero_value_tags()
    {}
  end
  # @private
  def self._porcelain_zero_value_access_rules()
    []
  end
end
