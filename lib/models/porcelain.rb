# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal This file was generated by protogen. DO NOT EDIT.

module SDM
  class AKS
    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSBasicAuth
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccount
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil,
      token: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccountUserImpersonation
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil,
      token: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSUserImpersonation
    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWS
    attr_accessor :access_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :healthcheck_region
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      egress_filter: nil,
      healthcheck_region: nil,
      healthy: nil,
      id: nil,
      name: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_region = healthcheck_region == nil ? "" : healthcheck_region
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :region
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      region: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachments assign an account to a role.
  class AccountAttachment
    # The id of the account of this AccountAttachment.
    attr_accessor :account_id
    # Unique identifier of the AccountAttachment.
    attr_accessor :id
    # The id of the attached role of this AccountAttachment.
    attr_accessor :role_id

    def initialize(
      account_id: nil,
      id: nil,
      role_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentCreateResponse reports how the AccountAttachments were created in the system.
  class AccountAttachmentCreateResponse
    # The created AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentDeleteResponse returns information about a AccountAttachment that was deleted.
  class AccountAttachmentDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentGetResponse returns a requested AccountAttachment.
  class AccountAttachmentGetResponse
    # The requested AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountCreateResponse reports how the Accounts were created in the system.
  class AccountCreateResponse
    # The created Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Account. The Account will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil,
      token: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountDeleteResponse returns information about a Account that was deleted.
  class AccountDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGetResponse returns a requested Account.
  class AccountGetResponse
    # The requested Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrants connect a resource directly to an account, giving the account the permission to connect to that resource.
  class AccountGrant
    # The id of the attached role of this AccountGrant.
    attr_accessor :account_id
    # Unique identifier of the AccountGrant.
    attr_accessor :id
    # The id of the composite role of this AccountGrant.
    attr_accessor :resource_id
    # The timestamp when the resource will be granted. Optional. Both start_at
    # and end_at must be defined together, or not defined at all.
    attr_accessor :start_from
    # The timestamp when the resource grant will expire. Optional. Both
    # start_at and end_at must be defined together, or not defined at all.
    attr_accessor :valid_until

    def initialize(
      account_id: nil,
      id: nil,
      resource_id: nil,
      start_from: nil,
      valid_until: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
      @valid_until = valid_until == nil ? nil : valid_until
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantCreateResponse reports how the AccountGrants were created in the system.
  class AccountGrantCreateResponse
    # The created AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantDeleteResponse returns information about a AccountGrant that was deleted.
  class AccountGrantDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantGetResponse returns a requested AccountGrant.
  class AccountGrantGetResponse
    # The requested AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountUpdateResponse returns the fields of a Account after it has been updated by
  # a AccountUpdateRequest.
  class AccountUpdateResponse
    # The updated Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKS
    attr_accessor :access_key

    attr_accessor :certificate_authority

    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSUserImpersonation
    attr_accessor :access_key

    attr_accessor :certificate_authority

    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonES
    attr_accessor :access_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonMQAMQP091
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Athena
    attr_accessor :access_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :output

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      output: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @output = output == nil ? "" : output
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraMysql
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraPostgres
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Azure
    attr_accessor :app_id
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      password: nil,
      secret_store_id: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureCertificate
    attr_accessor :app_id

    attr_accessor :client_certificate
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      client_certificate: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzurePostgres
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :vault_uri

    def initialize(
      id: nil,
      name: nil,
      tags: nil,
      vault_uri: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @vault_uri = vault_uri == nil ? "" : vault_uri
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class BigQuery
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :private_key

    attr_accessor :project
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      private_key: nil,
      project: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @project = project == nil ? "" : project
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cassandra
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Citus
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Clustrix
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cockroach
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelGetSSHCAPublicKeyResponse represents a request for an
  # organization's SSH Certificate Authority public key.
  class ControlPanelGetSSHCAPublicKeyResponse
    # Reserved for future use.
    attr_accessor :meta
    # The public key of the SSH Certificate Authority, in OpenSSH RSA public
    # key format.
    attr_accessor :public_key
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      public_key: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @public_key = public_key == nil ? "" : public_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelVerifyJWTResponse reports whether x-sdm-token is valid.
  class ControlPanelVerifyJWTResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # Reports if the given token is valid.
    attr_accessor :valid

    def initialize(
      meta: nil,
      rate_limit: nil,
      valid: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @valid = valid == nil ? false : valid
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CreateResponseMetadata is reserved for future use.
  class CreateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2I
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2LUW
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # DeleteResponseMetadata is reserved for future use.
  class DeleteResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBHost
    attr_accessor :auth_database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      auth_database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBReplicaSet
    attr_accessor :auth_database

    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      auth_database: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Druid
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DynamoDB
    attr_accessor :access_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Elastic
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ElasticacheRedis
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCP
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id

    attr_accessor :keyfile
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :scopes
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      egress_filter: nil,
      healthy: nil,
      id: nil,
      keyfile: nil,
      name: nil,
      scopes: nil,
      secret_store_id: nil,
      tags: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @keyfile = keyfile == nil ? "" : keyfile
      @name = name == nil ? "" : name
      @scopes = scopes == nil ? "" : scopes
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCPStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :projectid
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      projectid: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @projectid = projectid == nil ? "" : projectid
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Gateway represents a StrongDM CLI installation running in gateway mode.
  class Gateway
    # The hostname/port tuple which the gateway daemon will bind to.
    # If not provided on create, set to "0.0.0.0:listen_address_port".
    attr_accessor :bind_address
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways.
    attr_accessor :gateway_filter
    # Unique identifier of the Gateway.
    attr_accessor :id
    # The public hostname/port tuple at which the gateway will be accessible to clients.
    attr_accessor :listen_address
    # Unique human-readable name of the Gateway. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the gateway. One of: "new", "verifying_restart",
    # "restarting", "started", "stopped", "dead", "unknown"
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_address: nil,
      gateway_filter: nil,
      id: nil,
      listen_address: nil,
      name: nil,
      state: nil,
      tags: nil
    )
      @bind_address = bind_address == nil ? "" : bind_address
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @listen_address = listen_address == nil ? "" : listen_address
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # GetResponseMetadata is reserved for future use.
  class GetResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKE
    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :service_account_key
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      service_account_key: nil,
      tags: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKEUserImpersonation
    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :service_account_key
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      service_account_key: nil,
      tags: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Greenplum
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPAuth
    attr_accessor :auth_header

    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :headers_blacklist

    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :url

    def initialize(
      auth_header: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @auth_header = auth_header == nil ? "" : auth_header
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPBasicAuth
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :headers_blacklist

    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :url

    attr_accessor :username

    def initialize(
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      id: nil,
      name: nil,
      password: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil,
      username: nil
    )
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPNoAuth
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :headers_blacklist

    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :url

    def initialize(
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Kubernetes
    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesBasicAuth
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccount
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil,
      token: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccountUserImpersonation
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :token

    def initialize(
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil,
      token: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesUserImpersonation
    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      secret_store_id: nil,
      tags: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MTLSPostgres
    attr_accessor :certificate_authority

    attr_accessor :client_certificate

    attr_accessor :client_key

    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id

    attr_accessor :server_name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      server_name: nil,
      tags: nil,
      username: nil
    )
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Maria
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memcached
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memsql
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoHost
    attr_accessor :auth_database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoLegacyHost
    attr_accessor :auth_database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoLegacyReplicaset
    attr_accessor :auth_database

    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoReplicaSet
    attr_accessor :auth_database

    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoShardedCluster
    attr_accessor :auth_database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      auth_database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Mysql
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Neptune
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class NeptuneIAM
    attr_accessor :access_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter

    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :region

    attr_accessor :role_arn

    attr_accessor :role_external_id

    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeCreateResponse reports how the Nodes were created in the system.
  class NodeCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Node. The Node will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil,
      token: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeDeleteResponse returns information about a Node that was deleted.
  class NodeDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeGetResponse returns a requested Node.
  class NodeGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeUpdateResponse returns the fields of a Node after it has been updated by
  # a NodeUpdateRequest.
  class NodeUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The updated Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Oracle
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Postgres
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Presto
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RDP
    attr_accessor :downgrade_nla_connections
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      downgrade_nla_connections: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @downgrade_nla_connections = downgrade_nla_connections == nil ? false : downgrade_nla_connections
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RabbitMQAMQP091
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :tls_required

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RateLimitMetadata contains information about remaining requests avaialable
  # to the user over some timeframe.
  class RateLimitMetadata
    # The bucket this user/token is associated with, which may be shared between
    # multiple users/tokens.
    attr_accessor :bucket
    # How many total requests the user/token is authorized to make before being
    # rate limited.
    attr_accessor :limit
    # How many remaining requests out of the limit are still avaialable.
    attr_accessor :remaining
    # The time when remaining will be reset to limit.
    attr_accessor :reset_at

    def initialize(
      bucket: nil,
      limit: nil,
      remaining: nil,
      reset_at: nil
    )
      @bucket = bucket == nil ? "" : bucket
      @limit = limit == nil ? 0 : limit
      @remaining = remaining == nil ? 0 : remaining
      @reset_at = reset_at == nil ? nil : reset_at
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RawTCP
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redis
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redshift
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Relay represents a StrongDM CLI installation running in relay mode.
  class Relay
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways.
    attr_accessor :gateway_filter
    # Unique identifier of the Relay.
    attr_accessor :id
    # Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the relay. One of: "new", "verifying_restart",
    # "awaiting_restart", "restarting", "started", "stopped", "dead",
    # "unknown".
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      gateway_filter: nil,
      id: nil,
      name: nil,
      state: nil,
      tags: nil
    )
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceCreateResponse reports how the Resources were created in the system.
  class ResourceCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceDeleteResponse returns information about a Resource that was deleted.
  class ResourceDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceGetResponse returns a requested Resource.
  class ResourceGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceUpdateResponse returns the fields of a Resource after it has been updated by
  # a ResourceUpdateRequest.
  class ResourceUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Role has a list of access rules which determine which Resources the members
  # of the Role have access to. An Account can be a member of multiple Roles via
  # AccountAttachments.
  class Role
    # AccessRules is a list of access rules defining the resources this Role has access to.
    attr_accessor :access_rules
    # Composite is true if the Role is a composite role.
    #
    # Deprecated: composite roles are deprecated, use multi-role via
    # AccountAttachments instead.
    attr_accessor :composite
    # Unique identifier of the Role.
    attr_accessor :id
    # Unique human-readable name of the Role.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_rules: nil,
      composite: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @access_rules = access_rules == nil ? SDM::_porcelain_zero_value_access_rules() : access_rules
      @composite = composite == nil ? false : composite
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A RoleAttachment assigns a role to a composite role.
  #
  # Deprecated: use multi-role via AccountAttachments instead.
  class RoleAttachment
    # The id of the attached role of this RoleAttachment.
    attr_accessor :attached_role_id
    # The id of the composite role of this RoleAttachment.
    attr_accessor :composite_role_id
    # Unique identifier of the RoleAttachment.
    attr_accessor :id

    def initialize(
      attached_role_id: nil,
      composite_role_id: nil,
      id: nil
    )
      @attached_role_id = attached_role_id == nil ? "" : attached_role_id
      @composite_role_id = composite_role_id == nil ? "" : composite_role_id
      @id = id == nil ? "" : id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleAttachmentCreateResponse reports how the RoleAttachments were created in the system.
  #
  # Deprecated: use multi-role via AccountAttachments instead.
  class RoleAttachmentCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created RoleAttachment.
    attr_accessor :role_attachment

    def initialize(
      meta: nil,
      rate_limit: nil,
      role_attachment: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role_attachment = role_attachment == nil ? nil : role_attachment
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleAttachmentDeleteResponse returns information about a RoleAttachment that was deleted.
  #
  # Deprecated: use multi-role via AccountAttachments instead.
  class RoleAttachmentDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleAttachmentGetResponse returns a requested RoleAttachment.
  #
  # Deprecated: use multi-role via AccountAttachments instead.
  class RoleAttachmentGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RoleAttachment.
    attr_accessor :role_attachment

    def initialize(
      meta: nil,
      rate_limit: nil,
      role_attachment: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role_attachment = role_attachment == nil ? nil : role_attachment
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleCreateResponse reports how the Roles were created in the system. It can
  # communicate partial successes or failures.
  class RoleCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleDeleteResponse returns information about a Role that was deleted.
  class RoleDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGetResponse returns a requested Role.
  class RoleGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A RoleGrant connects a resource to a role, granting members of the role access to that resource.
  #
  # Deprecated: use Role access rules instead.
  class RoleGrant
    # Unique identifier of the RoleGrant.
    attr_accessor :id
    # The id of the resource of this RoleGrant.
    attr_accessor :resource_id
    # The id of the attached role of this RoleGrant.
    attr_accessor :role_id

    def initialize(
      id: nil,
      resource_id: nil,
      role_id: nil
    )
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGrantCreateResponse reports how the RoleGrants were created in the system.
  #
  # Deprecated: use Role access rules instead.
  class RoleGrantCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created RoleGrant.
    attr_accessor :role_grant

    def initialize(
      meta: nil,
      rate_limit: nil,
      role_grant: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role_grant = role_grant == nil ? nil : role_grant
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGrantDeleteResponse returns information about a RoleGrant that was deleted.
  #
  # Deprecated: use Role access rules instead.
  class RoleGrantDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGrantGetResponse returns a requested RoleGrant.
  #
  # Deprecated: use Role access rules instead.
  class RoleGrantGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RoleGrant.
    attr_accessor :role_grant

    def initialize(
      meta: nil,
      rate_limit: nil,
      role_grant: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role_grant = role_grant == nil ? nil : role_grant
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleUpdateResponse returns the fields of a Role after it has been updated by
  # a RoleUpdateRequest.
  class RoleUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServer
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :override_database

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override

    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      schema: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSH
    attr_accessor :allow_deprecated_key_exchanges
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_forwarding

    attr_accessor :public_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      public_key: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @public_key = public_key == nil ? "" : public_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCert
    attr_accessor :allow_deprecated_key_exchanges
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_forwarding
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCustomerKey
    attr_accessor :allow_deprecated_key_exchanges
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :port

    attr_accessor :port_forwarding

    attr_accessor :private_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      private_key: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @private_key = private_key == nil ? "" : private_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreCreateResponse reports how the SecretStores were created in the system.
  class SecretStoreCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreDeleteResponse returns information about a SecretStore that was deleted.
  class SecretStoreDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreGetResponse returns a requested SecretStore.
  class SecretStoreGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreUpdateResponse returns the fields of a SecretStore after it has been updated by
  # a SecretStoreUpdateRequest.
  class SecretStoreUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Service is a service account that can connect to resources they are granted
  # directly, or granted via roles. Services are typically automated jobs.
  class Service
    # Unique identifier of the Service.
    attr_accessor :id
    # Unique human-readable name of the Service.
    attr_accessor :name
    # The Service's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      suspended: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SingleStore
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Snowflake
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port_override

    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      schema: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Sybase
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SybaseIQ
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Tag
    attr_accessor :name

    attr_accessor :value

    def initialize(
      name: nil,
      value: nil
    )
      @name = name == nil ? "" : name
      @value = value == nil ? "" : value
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Teradata
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy

    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name

    attr_accessor :password

    attr_accessor :port

    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    attr_accessor :username

    def initialize(
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      tags: nil,
      username: nil
    )
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # UpdateResponseMetadata is reserved for future use.
  class UpdateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A User can connect to resources they are granted directly, or granted
  # via roles.
  class User
    # The User's email address. Must be unique.
    attr_accessor :email
    # The User's first name.
    attr_accessor :first_name
    # Unique identifier of the User.
    attr_accessor :id
    # The User's last name.
    attr_accessor :last_name
    # The User's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      email: nil,
      first_name: nil,
      id: nil,
      last_name: nil,
      suspended: nil,
      tags: nil
    )
      @email = email == nil ? "" : email
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultAppRoleStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :namespace

    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTLSStore
    attr_accessor :ca_cert_path

    attr_accessor :client_cert_path

    attr_accessor :client_key_path
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :namespace

    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_cert_path: nil,
      client_cert_path: nil,
      client_key_path: nil,
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @ca_cert_path = ca_cert_path == nil ? "" : ca_cert_path
      @client_cert_path = client_cert_path == nil ? "" : client_cert_path
      @client_key_path = client_key_path == nil ? "" : client_key_path
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTokenStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name

    attr_accessor :namespace

    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  def self._porcelain_zero_value_tags()
    {}
  end
  def self._porcelain_zero_value_access_rules()
    []
  end
end
