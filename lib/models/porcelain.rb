# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal Code generated by protogen. DO NOT EDIT.

module SDM
  class AKS
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AKSBasicAuth is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class AKSBasicAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccount
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccountUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWS
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The AWS region healthcheck requests should attempt to connect to.
    attr_accessor :healthcheck_region
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_region: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_region = healthcheck_region == nil ? "" : healthcheck_region
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSCertX509Store
    # The ARN of the CA in AWS Private CA
    attr_accessor :caarn
    # The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
    attr_accessor :certificatetemplatearn
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA represented in minutes.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The AWS region to target e.g. us-east-1
    attr_accessor :region
    # The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
    attr_accessor :signingalgo
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      caarn: nil,
      certificatetemplatearn: nil,
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      region: nil,
      signingalgo: nil,
      tags: nil
    )
      @caarn = caarn == nil ? "" : caarn
      @certificatetemplatearn = certificatetemplatearn == nil ? "" : certificatetemplatearn
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @signingalgo = signingalgo == nil ? "" : signingalgo
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSConsole
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
    attr_accessor :enable_env_variables
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The length of time in seconds AWS console sessions will live before needing to reauthenticate.
    attr_accessor :session_expiry
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      enable_env_variables: nil,
      healthy: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      session_expiry: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @enable_env_variables = enable_env_variables == nil ? false : enable_env_variables
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @session_expiry = session_expiry == nil ? 0 : session_expiry
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSConsoleStaticKeyPair
    # The Access Key ID to authenticate with.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to authenticate with.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The length of time in seconds AWS console sessions will live before needing to reauthenticate.
    attr_accessor :session_expiry
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      session_expiry: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @session_expiry = session_expiry == nil ? 0 : session_expiry
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The AWS region to target e.g. us-east-1
    attr_accessor :region
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      region: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequests are requests for access to a resource that may match a Workflow.
  class AccessRequest
    # The account that initiated the request.
    attr_accessor :account_id
    # Duration of the access request.
    attr_accessor :duration
    # The account grant created, if it exists.
    attr_accessor :grant_id
    # The access request id.
    attr_accessor :id
    # The reason the access was requested.
    attr_accessor :reason
    # The resource id.
    attr_accessor :resource_id
    # The timestamp when the requested access will be granted.
    # If this field is not specified it will default to the current time.
    attr_accessor :start_from
    # The status of the access request.
    attr_accessor :status
    # The timestamp when the status changed.
    attr_accessor :status_at
    # The timestamp when the requested access will expire.
    attr_accessor :valid_until
    # The workflow the request bound to.
    attr_accessor :workflow_id

    def initialize(
      account_id: nil,
      duration: nil,
      grant_id: nil,
      id: nil,
      reason: nil,
      resource_id: nil,
      start_from: nil,
      status: nil,
      status_at: nil,
      valid_until: nil,
      workflow_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @duration = duration == nil ? 0 : duration
      @grant_id = grant_id == nil ? "" : grant_id
      @id = id == nil ? "" : id
      @reason = reason == nil ? "" : reason
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
      @status = status == nil ? "" : status
      @status_at = status_at == nil ? nil : status_at
      @valid_until = valid_until == nil ? nil : valid_until
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestConfig holds the information required to request access to a resource
  class AccessRequestConfig
    # The time access should end, defaults to the next occurance of 5 pm
    attr_accessor :duration
    # The reason for access
    attr_accessor :reason
    # The resource for which access is being requested
    attr_accessor :resource_id
    # The time access should start, defaults to now
    attr_accessor :start_from

    def initialize(
      duration: nil,
      reason: nil,
      resource_id: nil,
      start_from: nil
    )
      @duration = duration == nil ? "" : duration
      @reason = reason == nil ? "" : reason
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestEvents hold information about events related to an access
  # request such as creation, approval and denial.
  class AccessRequestEvent
    # The account responsible for the event.
    attr_accessor :actor_id
    # The access request event id.
    attr_accessor :id
    # The metadata about the event
    attr_accessor :metadata
    # The request that the event is bound to.
    attr_accessor :request_id
    # The type of event.
    attr_accessor :type

    def initialize(
      actor_id: nil,
      id: nil,
      metadata: nil,
      request_id: nil,
      type: nil
    )
      @actor_id = actor_id == nil ? "" : actor_id
      @id = id == nil ? "" : id
      @metadata = metadata == nil ? "" : metadata
      @request_id = request_id == nil ? "" : request_id
      @type = type == nil ? "" : type
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestEventHistory records the state of a AccessRequest at a given point in time,
  # where every change (create, update and delete) to a AccessRequest produces an
  # AccessRequestEventHistory record.
  class AccessRequestEventHistory
    # The complete AccessRequestEvent state at this time.
    attr_accessor :access_request_event
    # The unique identifier of the Activity that produced this change to the AccessRequest.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccessRequest state was recorded.
    attr_accessor :timestamp

    def initialize(
      access_request_event: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @access_request_event = access_request_event == nil ? nil : access_request_event
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestHistory records the state of a AccessRequest at a given point in time,
  # where every change (create, update and delete) to a AccessRequest produces an
  # AccessRequestHistory record.
  class AccessRequestHistory
    # The complete AccessRequest state at this time.
    attr_accessor :access_request
    # The unique identifier of the Activity that produced this change to the AccessRequest.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccessRequest state was recorded.
    attr_accessor :timestamp

    def initialize(
      access_request: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @access_request = access_request == nil ? nil : access_request
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestListRequest specifies criteria for retrieving a list of
  # AccessRequest records
  class AccessRequestListRequest
    # A human-readable filter query string.
    attr_accessor :filter

    def initialize(
      filter: nil
    )
      @filter = filter == nil ? "" : filter
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestListResponse returns a list of access requests records that meet
  # the criteria of a AccessRequestListRequest.
  class AccessRequestListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachments assign an account to a role.
  class AccountAttachment
    # The id of the account of this AccountAttachment.
    attr_accessor :account_id
    # Unique identifier of the AccountAttachment.
    attr_accessor :id
    # The id of the attached role of this AccountAttachment.
    attr_accessor :role_id

    def initialize(
      account_id: nil,
      id: nil,
      role_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentCreateResponse reports how the AccountAttachments were created in the system.
  class AccountAttachmentCreateResponse
    # The created AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentDeleteResponse returns information about a AccountAttachment that was deleted.
  class AccountAttachmentDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentGetResponse returns a requested AccountAttachment.
  class AccountAttachmentGetResponse
    # The requested AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentHistory records the state of an AccountAttachment at a given point in time,
  # where every change (create or delete) to an AccountAttachment produces an
  # AccountAttachmentHistory record.
  class AccountAttachmentHistory
    # The complete AccountAttachment state at this time.
    attr_accessor :account_attachment
    # The unique identifier of the Activity that produced this change to the AccountAttachment.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountAttachment was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountAttachment state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_attachment: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountCreateResponse reports how the Accounts were created in the system.
  class AccountCreateResponse
    # ID part of the API key.
    attr_accessor :access_key
    # The created Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # Secret part of the API key.
    attr_accessor :secret_key
    # The auth token generated for the Account. The Account will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      access_key: nil,
      account: nil,
      meta: nil,
      rate_limit: nil,
      secret_key: nil,
      token: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_key = secret_key == nil ? "" : secret_key
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountDeleteResponse returns information about a Account that was deleted.
  class AccountDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGetResponse returns a requested Account.
  class AccountGetResponse
    # The requested Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrants connect a resource directly to an account, giving the account the permission to connect to that resource.
  class AccountGrant
    # The account ID of this AccountGrant.
    attr_accessor :account_id
    # Unique identifier of the AccountGrant.
    attr_accessor :id
    # The resource ID of this AccountGrant.
    attr_accessor :resource_id
    # The timestamp when the resource will be granted. When creating an AccountGrant, if this field is not specified, it will default to the current time.
    attr_accessor :start_from
    # The timestamp when the resource grant will expire.
    attr_accessor :valid_until

    def initialize(
      account_id: nil,
      id: nil,
      resource_id: nil,
      start_from: nil,
      valid_until: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
      @valid_until = valid_until == nil ? nil : valid_until
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantCreateResponse reports how the AccountGrants were created in the system.
  class AccountGrantCreateResponse
    # The created AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantDeleteResponse returns information about a AccountGrant that was deleted.
  class AccountGrantDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantGetResponse returns a requested AccountGrant.
  class AccountGrantGetResponse
    # The requested AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantHistory records the state of an AccountGrant at a given point in time,
  # where every change (create or delete) to an AccountGrant produces an
  # AccountGrantHistory record.
  class AccountGrantHistory
    # The complete AccountGrant state at this time.
    attr_accessor :account_grant
    # The unique identifier of the Activity that produced this change to the AccountGrant.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountGrant was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountGrant state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_grant: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountHistory records the state of an Account at a given point in time,
  # where every change (create, update and delete) to an Account produces an
  # AccountHistory record.
  class AccountHistory
    # The complete Account state at this time.
    attr_accessor :account
    # The unique identifier of the Activity that produced this change to the Account.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Account was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Account state was recorded.
    attr_accessor :timestamp

    def initialize(
      account: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account = account == nil ? nil : account
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountPermission represents an individual API action available to an account.
  class AccountPermission
    # The unique identifier of the Account this permission belongs to.
    attr_accessor :account_id
    # The most recent time at which the permission was granted. If a permission was
    # granted, revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The value of this permission, split into vertical and action, one of the Permission constants.
    attr_accessor :permission
    # The scope of this permission. A global scope means this action can be taken
    # on any entity; otherwise the action can only be taken on or in the scope of
    # the scoped id.
    attr_accessor :scope
    # The ID to which or in whose context this operation is permitted. e.g. The ID of a
    # role that a team leader has the abillity to remove and add accounts to, or the
    # ID of a resource that a user has the permission to connect to. If Scope is global,
    # scoped id is not populated.
    attr_accessor :scoped_id

    def initialize(
      account_id: nil,
      granted_at: nil,
      permission: nil,
      scope: nil,
      scoped_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @granted_at = granted_at == nil ? nil : granted_at
      @permission = permission == nil ? "" : permission
      @scope = scope == nil ? "" : scope
      @scoped_id = scoped_id == nil ? "" : scoped_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountResource represents an individual access grant of a Account to a Resource.
  class AccountResource
    # The unique identifier of the AccountGrant through which the Account was granted access to the Resource.
    # If empty, access was not granted through an AccountGrant.
    attr_accessor :account_grant_id
    # The unique identifier of the Account to which access is granted.
    attr_accessor :account_id
    # The time this grant was created, distinct from 'granted at' in the case where access is scheduled
    # for the future. If access was granted, revoked, and granted again, this will reflect the later creation time.
    attr_accessor :created_at
    # The time at which access will expire. If empty, this access has no expiration.
    attr_accessor :expires_at
    # The most recent time at which access was granted. If access was granted,
    # revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The unique identifier of the Resource to which access is granted.
    attr_accessor :resource_id
    # The unique identifier of the Role through which the Account was granted access to the Resource.
    # If empty, access was not granted through an AccountAttachment to a Role.
    attr_accessor :role_id

    def initialize(
      account_grant_id: nil,
      account_id: nil,
      created_at: nil,
      expires_at: nil,
      granted_at: nil,
      resource_id: nil,
      role_id: nil
    )
      @account_grant_id = account_grant_id == nil ? "" : account_grant_id
      @account_id = account_id == nil ? "" : account_id
      @created_at = created_at == nil ? nil : created_at
      @expires_at = expires_at == nil ? nil : expires_at
      @granted_at = granted_at == nil ? nil : granted_at
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountResourceHistory records the state of a AccountResource at a given point in time,
  # where every change (create or delete) to a AccountResource produces an
  # AccountResourceHistory record.
  class AccountResourceHistory
    # The complete AccountResource state at this time.
    attr_accessor :account_resource
    # The unique identifier of the Activity that produced this change to the AccountResource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountResource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountResource state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_resource: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_resource = account_resource == nil ? nil : account_resource
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountUpdateResponse returns the fields of a Account after it has been updated by
  # a AccountUpdateRequest.
  class AccountUpdateResponse
    # The updated Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActiveDirectoryStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Hostname of server that is hosting NDES (Network Device Enrollment Services).
    # Often this is the same host as Active Directory Certificate Services
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # An Activity is a record of an action taken against a strongDM deployment, e.g.
  # a user creation, resource deletion, sso configuration change, etc.
  class Activity
    # The account who executed this activity. If the actor later has a name or email change,
    # that change is not reflected here. Actor is a snapshot of the executing account at
    # the time an activity took place.
    attr_accessor :actor
    # The time this activity took effect.
    attr_accessor :completed_at
    # A humanized description of the activity.
    attr_accessor :description
    # The entities involved in this activity. These entities can be any first class
    # entity in the strongDM system, eg. a user, a role, a node, an account grant. Not
    # every activity affects explicit entities.
    attr_accessor :entities
    # Unique identifier of the Activity.
    attr_accessor :id
    # The IP from which this action was taken.
    attr_accessor :ip_address
    # The User Agent present when this request was executed. Generally a client type and version
    # like strongdm-cli/55.66.77
    attr_accessor :user_agent
    # The kind of activity which has taken place, one of the ActivityVerb constants.
    attr_accessor :verb

    def initialize(
      actor: nil,
      completed_at: nil,
      description: nil,
      entities: nil,
      id: nil,
      ip_address: nil,
      user_agent: nil,
      verb: nil
    )
      @actor = actor == nil ? nil : actor
      @completed_at = completed_at == nil ? nil : completed_at
      @description = description == nil ? "" : description
      @entities = entities == nil ? [] : entities
      @id = id == nil ? "" : id
      @ip_address = ip_address == nil ? "" : ip_address
      @user_agent = user_agent == nil ? "" : user_agent
      @verb = verb == nil ? "" : verb
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActivityActor
    # The external ID of the actor at the time this activity occurred.
    attr_accessor :activity_external_id
    # The email of the actor at the time this activity occurred.
    attr_accessor :email
    # The first name of the actor at the time this activity occurred.
    attr_accessor :first_name
    # Unique identifier of the actor. Immutable.
    attr_accessor :id
    # The last name of the actor at the time this activity occurred.
    attr_accessor :last_name

    def initialize(
      activity_external_id: nil,
      email: nil,
      first_name: nil,
      id: nil,
      last_name: nil
    )
      @activity_external_id = activity_external_id == nil ? "" : activity_external_id
      @email = email == nil ? "" : email
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActivityEntity
    # The email of the affected entity, if it has one (for example, if it is an account).
    attr_accessor :email
    # The external ID of the affected entity, if it has one (for example, if it is an account).
    attr_accessor :external_id
    # The unique identifier of the entity this activity affected.
    attr_accessor :id
    # A display name representing the affected entity.
    attr_accessor :name
    # The type of entity affected, one of the ActivityEntityType constants.
    attr_accessor :type

    def initialize(
      email: nil,
      external_id: nil,
      id: nil,
      name: nil,
      type: nil
    )
      @email = email == nil ? "" : email
      @external_id = external_id == nil ? "" : external_id
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @type = type == nil ? "" : type
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ActivityGetResponse returns a requested Activity.
  class ActivityGetResponse
    # The requested Activity.
    attr_accessor :activity
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      activity: nil,
      meta: nil,
      rate_limit: nil
    )
      @activity = activity == nil ? nil : activity
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKS
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSInstanceProfile
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSInstanceProfileUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSUserImpersonation
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonES
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial e.g. search-?.region.es.amazonaws.com"
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonMQAMQP091
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflows are the mechanism by which requests for access can be viewed by authorized
  # approvers and be approved or denied.
  class ApprovalWorkflow
    # Approval mode of the ApprovalWorkflow
    attr_accessor :approval_mode
    # Optional description of the ApprovalWorkflow.
    attr_accessor :description
    # Unique identifier of the ApprovalWorkflow.
    attr_accessor :id
    # Unique human-readable name of the ApprovalWorkflow.
    attr_accessor :name

    def initialize(
      approval_mode: nil,
      description: nil,
      id: nil,
      name: nil
    )
      @approval_mode = approval_mode == nil ? "" : approval_mode
      @description = description == nil ? "" : description
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowApprover links an approval workflow approver to an ApprovalWorkflowStep
  class ApprovalWorkflowApprover
    # The approver account id.
    attr_accessor :account_id
    # The approval flow id specified the approval workflow that this approver belongs to
    attr_accessor :approval_flow_id
    # The approval step id specified the approval flow step that this approver belongs to
    attr_accessor :approval_step_id
    # Unique identifier of the ApprovalWorkflowApprover.
    attr_accessor :id
    # The approver role id
    attr_accessor :role_id

    def initialize(
      account_id: nil,
      approval_flow_id: nil,
      approval_step_id: nil,
      id: nil,
      role_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @approval_flow_id = approval_flow_id == nil ? "" : approval_flow_id
      @approval_step_id = approval_step_id == nil ? "" : approval_step_id
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowApproverCreateResponse reports how the ApprovalWorkflowApprover was created in the system.
  class ApprovalWorkflowApproverCreateResponse
    # The created approval workflow approver.
    attr_accessor :approval_workflow_approver
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow_approver: nil,
      rate_limit: nil
    )
      @approval_workflow_approver = approval_workflow_approver == nil ? nil : approval_workflow_approver
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowApproverDeleteResponse returns information about an ApprovalWorkflowApprover that was deleted.
  class ApprovalWorkflowApproverDeleteResponse
    # The deleted approval workflow approver id.
    attr_accessor :id
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      id: nil,
      rate_limit: nil
    )
      @id = id == nil ? "" : id
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowApproverGetResponse returns a requested ApprovalWorkflowApprover.
  class ApprovalWorkflowApproverGetResponse
    # The requested ApprovalWorkflowApprover.
    attr_accessor :approval_workflow_approver
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow_approver: nil,
      meta: nil,
      rate_limit: nil
    )
      @approval_workflow_approver = approval_workflow_approver == nil ? nil : approval_workflow_approver
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowApproverHistory records the state of an ApprovalWorkflowApprover at a given point in time,
  # where every change (create or delete) to an ApprovalWorkflowApprover produces an
  # ApprovalWorkflowApproverHistory record.
  class ApprovalWorkflowApproverHistory
    # The unique identifier of the Activity that produced this change to the ApprovalWorkflowApprover.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # The complete ApprovalWorkflowApprover state at this time.
    attr_accessor :approval_workflow_approver
    # If this ApprovalWorkflowApprover was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the ApprovalWorkflowApprover state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      approval_workflow_approver: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @approval_workflow_approver = approval_workflow_approver == nil ? nil : approval_workflow_approver
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowApproverListResponse returns a list of ApprovalWorkflowApprover records that meet
  # the criteria of an ApprovalWorkflowApproverListRequest.
  class ApprovalWorkflowApproverListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowCreateResponse reports how the ApprovalWorkflow was created in the system.
  class ApprovalWorkflowCreateResponse
    # The created approval workflow.
    attr_accessor :approval_workflow
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow: nil,
      rate_limit: nil
    )
      @approval_workflow = approval_workflow == nil ? nil : approval_workflow
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowDeleteResponse returns information about an ApprovalWorkflow that was deleted.
  class ApprovalWorkflowDeleteResponse
    # The deleted approval workflow id.
    attr_accessor :id
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      id: nil,
      rate_limit: nil
    )
      @id = id == nil ? "" : id
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowGetResponse returns a requested ApprovalWorkflow.
  class ApprovalWorkflowGetResponse
    # The requested ApprovalWorkflow.
    attr_accessor :approval_workflow
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow: nil,
      meta: nil,
      rate_limit: nil
    )
      @approval_workflow = approval_workflow == nil ? nil : approval_workflow
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowHistory records the state of an ApprovalWorkflow at a given point in time,
  # where every change (create, update and delete) to an ApprovalWorkflow produces an
  # ApprovalWorkflowHistory record.
  class ApprovalWorkflowHistory
    # The unique identifier of the Activity that produced this change to the ApprovalWorkflow.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # The complete ApprovalWorkflow state at this time.
    attr_accessor :approval_workflow
    # If this ApprovalWorkflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the ApprovalWorkflow state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      approval_workflow: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @approval_workflow = approval_workflow == nil ? nil : approval_workflow
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowListResponse returns a list of ApprovalWorkflow records that meet
  # the criteria of an ApprovalWorkflowListRequest.
  class ApprovalWorkflowListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowStep links an approval workflow step to an ApprovalWorkflow
  class ApprovalWorkflowStep
    # The approval flow id specified the approval workfflow that this step belongs to
    attr_accessor :approval_flow_id
    # Unique identifier of the ApprovalWorkflowStep.
    attr_accessor :id

    def initialize(
      approval_flow_id: nil,
      id: nil
    )
      @approval_flow_id = approval_flow_id == nil ? "" : approval_flow_id
      @id = id == nil ? "" : id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowStepCreateResponse reports how the ApprovalWorkflowStep was created in the system.
  class ApprovalWorkflowStepCreateResponse
    # The created approval workflow step.
    attr_accessor :approval_workflow_step
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow_step: nil,
      rate_limit: nil
    )
      @approval_workflow_step = approval_workflow_step == nil ? nil : approval_workflow_step
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowStepDeleteResponse returns information about an ApprovalWorkflowStep that was deleted.
  class ApprovalWorkflowStepDeleteResponse
    # The deleted approval workflow step id.
    attr_accessor :id
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      id: nil,
      rate_limit: nil
    )
      @id = id == nil ? "" : id
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowStepGetResponse returns a requested ApprovalWorkflowStep.
  class ApprovalWorkflowStepGetResponse
    # The requested ApprovalWorkflowStep.
    attr_accessor :approval_workflow_step
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow_step: nil,
      meta: nil,
      rate_limit: nil
    )
      @approval_workflow_step = approval_workflow_step == nil ? nil : approval_workflow_step
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowStepHistory records the state of an ApprovalWorkflowStep at a given point in time,
  # where every change (create or delete) to an ApprovalWorkflowStep produces an
  # ApprovalWorkflowStepHistory record.
  class ApprovalWorkflowStepHistory
    # The unique identifier of the Activity that produced this change to the ApprovalWorkflowStep.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # The complete ApprovalWorkflowStep state at this time.
    attr_accessor :approval_workflow_step
    # If this ApprovalWorkflowStep was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the ApprovalWorkflowStep state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      approval_workflow_step: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @approval_workflow_step = approval_workflow_step == nil ? nil : approval_workflow_step
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowStepListResponse returns a list of ApprovalWorkflowStep records that meet
  # the criteria of an ApprovalWorkflowStepListRequest.
  class ApprovalWorkflowStepListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ApprovalWorkflowUpdateResponse returns the fields of an ApprovalWorkflow after it has been updated by
  # an ApprovalWorkflowUpdateRequest.
  class ApprovalWorkflowUpdateResponse
    # The updated approval workflow.
    attr_accessor :approval_workflow
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      approval_workflow: nil,
      rate_limit: nil
    )
      @approval_workflow = approval_workflow == nil ? nil : approval_workflow
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Athena
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The AWS S3 output location.
    attr_accessor :output
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      output: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @output = output == nil ? "" : output
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraMysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraPostgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraPostgresIAM
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to.
    attr_accessor :region
    # If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
    attr_accessor :role_assumption_arn
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_assumption_arn: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_assumption_arn = role_assumption_arn == nil ? "" : role_assumption_arn
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Azure
    # The application ID to authenticate with.
    attr_accessor :app_id
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The tenant ID to authenticate to.
    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureCertificate
    # The application ID to authenticate with.
    attr_accessor :app_id
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The service Principal certificate file, both private and public key included.
    attr_accessor :client_certificate
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The tenant ID to authenticate to.
    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      bind_interface: nil,
      client_certificate: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureMysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzurePostgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with. For Azure Postgres, this also will include the hostname of the target server for Azure Single Server compatibility. For Flexible servers, use the normal Postgres type.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzurePostgresManagedIdentity
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The URI of the key vault to target e.g. https://myvault.vault.azure.net
    attr_accessor :vault_uri

    def initialize(
      id: nil,
      name: nil,
      tags: nil,
      vault_uri: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @vault_uri = vault_uri == nil ? "" : vault_uri
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class BigQuery
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The JSON Private key to authenticate with.
    attr_accessor :private_key
    # The project to connect to.
    attr_accessor :project
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      private_key: nil,
      project: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @project = project == nil ? "" : project
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cassandra
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Citus
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Clustrix
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cockroach
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelGetRDPCAPublicKeyResponse represents a request for an
  # organization's RDP Certificate Authority public key.
  class ControlPanelGetRDPCAPublicKeyResponse
    # Reserved for future use.
    attr_accessor :meta
    # The public key of the SSH Certificate Authority, in OpenSSH RSA public
    # key format.
    attr_accessor :public_key
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      public_key: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @public_key = public_key == nil ? "" : public_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelGetSSHCAPublicKeyResponse represents a request for an
  # organization's SSH Certificate Authority public key.
  class ControlPanelGetSSHCAPublicKeyResponse
    # Reserved for future use.
    attr_accessor :meta
    # The public key of the SSH Certificate Authority, in OpenSSH RSA public
    # key format.
    attr_accessor :public_key
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      public_key: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @public_key = public_key == nil ? "" : public_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelVerifyJWTResponse reports whether x-sdm-token is valid.
  class ControlPanelVerifyJWTResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # Reports if the given token is valid.
    attr_accessor :valid

    def initialize(
      meta: nil,
      rate_limit: nil,
      valid: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @valid = valid == nil ? false : valid
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CouchbaseDatabase
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
    attr_accessor :n1ql_port
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      n1ql_port: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @n1ql_port = n1ql_port == nil ? 0 : n1ql_port
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CouchbaseWebUI
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CreateResponseMetadata is reserved for future use.
  class CreateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CyberarkConjurStore
    # The URL of the Cyberark instance
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CyberarkPAMExperimentalStore is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class CyberarkPAMExperimentalStore
    # The URL of the Cyberark instance
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CyberarkPAMStore
    # The URL of the Cyberark instance
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2I
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2LUW
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # DeleteResponseMetadata is reserved for future use.
  class DeleteResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DelineaStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The URL of the Delinea instance
    attr_accessor :server_url
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The tenant name to target
    attr_accessor :tenant_name

    def initialize(
      id: nil,
      name: nil,
      server_url: nil,
      tags: nil,
      tenant_name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @server_url = server_url == nil ? "" : server_url
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_name = tenant_name == nil ? "" : tenant_name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBHost
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBReplicaSet
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Set to connect to a replica instead of the primary node.
    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Druid
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DynamoDB
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial e.g. dynamodb.region.amazonaws.com
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The region to authenticate requests against e.g. us-east-1
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Elastic
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ElasticacheRedis
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCP
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The service account keyfile to authenticate with.
    attr_accessor :keyfile
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Space separated scopes that this login should assume into when authenticating.
    attr_accessor :scopes
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      keyfile: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      scopes: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @keyfile = keyfile == nil ? "" : keyfile
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @scopes = scopes == nil ? "" : scopes
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCPCertX509Store
    # The ID of the target CA
    attr_accessor :caid
    # The ID of the target CA pool
    attr_accessor :capoolid
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA represented in minutes.
    attr_accessor :issuedcertttlminutes
    # The Region for the CA in GCP format e.g. us-west1
    attr_accessor :location
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The GCP project ID to target.
    attr_accessor :projectid
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      caid: nil,
      capoolid: nil,
      id: nil,
      issuedcertttlminutes: nil,
      location: nil,
      name: nil,
      projectid: nil,
      tags: nil
    )
      @caid = caid == nil ? "" : caid
      @capoolid = capoolid == nil ? "" : capoolid
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @location = location == nil ? "" : location
      @name = name == nil ? "" : name
      @projectid = projectid == nil ? "" : projectid
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCPStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The GCP project ID to target.
    attr_accessor :projectid
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      projectid: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @projectid = projectid == nil ? "" : projectid
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Gateway represents a StrongDM CLI installation running in gateway mode.
  class Gateway
    # The hostname/port tuple which the gateway daemon will bind to.
    # If not provided on create, set to "0.0.0.0:listen_address_port".
    attr_accessor :bind_address
    # Device is a read only device name uploaded by the gateway process when
    # it comes online.
    attr_accessor :device
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways. Deprecated.
    attr_accessor :gateway_filter
    # Unique identifier of the Gateway.
    attr_accessor :id
    # The public hostname/port tuple at which the gateway will be accessible to clients.
    attr_accessor :listen_address
    # Location is a read only network location uploaded by the gateway process
    # when it comes online.
    attr_accessor :location
    # Maintenance Windows define when this node is allowed to restart. If a node
    # is requested to restart, it will check each window to determine if any of
    # them permit it to restart, and if any do, it will. This check is repeated
    # per window until the restart is successfully completed.
    #
    # If not set here, may be set on the command line or via an environment variable
    # on the process itself; any server setting will take precedence over local
    # settings. This setting is ineffective for nodes below version 38.44.0.
    #
    # If this setting is not applied via this remote configuration or via local
    # configuration, the default setting is used: always allow restarts if serving
    # no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
    attr_accessor :maintenance_windows
    # Unique human-readable name of the Gateway. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the gateway. One of: "new", "verifying_restart",
    # "restarting", "started", "stopped", "dead", "unknown"
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # Version is a read only sdm binary version uploaded by the gateway process
    # when it comes online.
    attr_accessor :version

    def initialize(
      bind_address: nil,
      device: nil,
      gateway_filter: nil,
      id: nil,
      listen_address: nil,
      location: nil,
      maintenance_windows: nil,
      name: nil,
      state: nil,
      tags: nil,
      version: nil
    )
      @bind_address = bind_address == nil ? "" : bind_address
      @device = device == nil ? "" : device
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @listen_address = listen_address == nil ? "" : listen_address
      @location = location == nil ? "" : location
      @maintenance_windows = maintenance_windows == nil ? [] : maintenance_windows
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @version = version == nil ? "" : version
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # GenericResponseMetadata contains common headers for generic request
  # responses.
  class GenericResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # GetResponseMetadata is reserved for future use.
  class GetResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKE
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The service account key to authenticate with.
    attr_accessor :service_account_key
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      certificate_authority: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      service_account_key: nil,
      subdomain: nil,
      tags: nil
    )
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKEUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The service account key to authenticate with.
    attr_accessor :service_account_key
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      service_account_key: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Greenplum
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPAuth
    # The content to set as the authorization header.
    attr_accessor :auth_header
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Automatically redirect to this path upon connecting.
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # Header names (e.g. Authorization), to omit from logs.
    attr_accessor :headers_blacklist
    # This path will be used to check the health of your site.
    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host header will be overwritten with this field if provided.
    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url

    def initialize(
      auth_header: nil,
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @auth_header = auth_header == nil ? "" : auth_header
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPBasicAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Automatically redirect to this path upon connecting.
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # Header names (e.g. Authorization), to omit from logs.
    attr_accessor :headers_blacklist
    # This path will be used to check the health of your site.
    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host header will be overwritten with this field if provided.
    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      password: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPNoAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Automatically redirect to this path upon connecting.
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # Header names (e.g. Authorization), to omit from logs.
    attr_accessor :headers_blacklist
    # This path will be used to check the health of your site.
    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host header will be overwritten with this field if provided.
    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url

    def initialize(
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentityAliases define the username to be used for a specific account
  # when connecting to a remote resource using that identity set.
  class IdentityAlias
    # The account for this identity alias.
    attr_accessor :account_id
    # Unique identifier of the IdentityAlias.
    attr_accessor :id
    # The identity set.
    attr_accessor :identity_set_id
    # The username to be used as the identity alias for this account.
    attr_accessor :username

    def initialize(
      account_id: nil,
      id: nil,
      identity_set_id: nil,
      username: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentityAliasCreateResponse reports how the IdentityAliases were created in the system.
  class IdentityAliasCreateResponse
    # The created IdentityAlias.
    attr_accessor :identity_alias
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      identity_alias: nil,
      meta: nil,
      rate_limit: nil
    )
      @identity_alias = identity_alias == nil ? nil : identity_alias
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentityAliasDeleteResponse returns information about a IdentityAlias that was deleted.
  class IdentityAliasDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentityAliasGetResponse returns a requested IdentityAlias.
  class IdentityAliasGetResponse
    # The requested IdentityAlias.
    attr_accessor :identity_alias
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      identity_alias: nil,
      meta: nil,
      rate_limit: nil
    )
      @identity_alias = identity_alias == nil ? nil : identity_alias
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentityAliasHistory records the state of a IdentityAlias at a given point in time,
  # where every change (create, update and delete) to a IdentityAlias produces an
  # IdentityAliasHistory record.
  class IdentityAliasHistory
    # The unique identifier of the Activity that produced this change to the IdentityAlias.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this IdentityAlias was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete IdentityAlias state at this time.
    attr_accessor :identity_alias
    # The time at which the IdentityAlias state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      identity_alias: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @identity_alias = identity_alias == nil ? nil : identity_alias
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentityAliasUpdateResponse returns the fields of a IdentityAlias after it has been updated by
  # a IdentityAliasUpdateRequest.
  class IdentityAliasUpdateResponse
    # The updated IdentityAlias.
    attr_accessor :identity_alias
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      identity_alias: nil,
      meta: nil,
      rate_limit: nil
    )
      @identity_alias = identity_alias == nil ? nil : identity_alias
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A IdentitySet defines a group of identity aliases.
  class IdentitySet
    # Unique identifier of the IdentitySet.
    attr_accessor :id
    # Unique human-readable name of the IdentitySet.
    attr_accessor :name

    def initialize(
      id: nil,
      name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentitySetCreateResponse reports how the IdentitySets were created in the system. It can
  # communicate partial successes or failures.
  class IdentitySetCreateResponse
    # The created IdentitySet.
    attr_accessor :identity_set
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      identity_set: nil,
      meta: nil,
      rate_limit: nil
    )
      @identity_set = identity_set == nil ? nil : identity_set
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentitySetDeleteResponse returns information about a IdentitySet that was deleted.
  class IdentitySetDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentitySetGetResponse returns a requested IdentitySet.
  class IdentitySetGetResponse
    # The requested IdentitySet.
    attr_accessor :identity_set
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      identity_set: nil,
      meta: nil,
      rate_limit: nil
    )
      @identity_set = identity_set == nil ? nil : identity_set
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentitySetHistory records the state of a IdentitySet at a given point in time,
  # where every change (create, update and delete) to a IdentitySet produces an
  # IdentitySetHistory record.
  class IdentitySetHistory
    # The unique identifier of the Activity that produced this change to the IdentitySet.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this IdentitySet was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete IdentitySet state at this time.
    attr_accessor :identity_set
    # The time at which the IdentitySet state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      identity_set: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @identity_set = identity_set == nil ? nil : identity_set
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # IdentitySetUpdateResponse returns the fields of a IdentitySet after it has been updated by
  # a IdentitySetUpdateRequest.
  class IdentitySetUpdateResponse
    # The updated IdentitySet.
    attr_accessor :identity_set
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      identity_set: nil,
      meta: nil,
      rate_limit: nil
    )
      @identity_set = identity_set == nil ? nil : identity_set
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KeyfactorSSHStore
    # Path to the root CA that signed the certificate passed to the client for HTTPS connection.
    # This is not required if the CA is trusted by the host operating system. This should be a PEM
    # formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
    attr_accessor :ca_file_path
    # Path to client certificate in PEM format. This certificate must contain a client certificate that
    # is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private
    # key associated with the certificate, but KeyFile can also be set to configure the private key.
    attr_accessor :certificate_file_path
    # Name of EJBCA certificate authority that will enroll CSR.
    attr_accessor :default_certificate_authority_name
    # Certificate profile name that EJBCA will enroll the CSR with.
    attr_accessor :default_certificate_profile_name
    # End entity profile that EJBCA will enroll the CSR with.
    attr_accessor :default_end_entity_profile_name
    # code used by EJBCA during enrollment. May be left blank if no code is required.
    attr_accessor :enrollment_code_env_var
    # username that used by the EJBCA during enrollment. This can be left out.
    # If so, the username must be auto-generated on the Keyfactor side.
    attr_accessor :enrollment_username_env_var
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Path to private key in PEM format. This file should contain the private key associated with the
    # client certificate configured in CertificateFile.
    attr_accessor :key_file_path
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # the host of the Key Factor CA
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_file_path: nil,
      certificate_file_path: nil,
      default_certificate_authority_name: nil,
      default_certificate_profile_name: nil,
      default_end_entity_profile_name: nil,
      enrollment_code_env_var: nil,
      enrollment_username_env_var: nil,
      id: nil,
      key_file_path: nil,
      name: nil,
      server_address: nil,
      tags: nil
    )
      @ca_file_path = ca_file_path == nil ? "" : ca_file_path
      @certificate_file_path = certificate_file_path == nil ? "" : certificate_file_path
      @default_certificate_authority_name = default_certificate_authority_name == nil ? "" : default_certificate_authority_name
      @default_certificate_profile_name = default_certificate_profile_name == nil ? "" : default_certificate_profile_name
      @default_end_entity_profile_name = default_end_entity_profile_name == nil ? "" : default_end_entity_profile_name
      @enrollment_code_env_var = enrollment_code_env_var == nil ? "" : enrollment_code_env_var
      @enrollment_username_env_var = enrollment_username_env_var == nil ? "" : enrollment_username_env_var
      @id = id == nil ? "" : id
      @key_file_path = key_file_path == nil ? "" : key_file_path
      @name = name == nil ? "" : name
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KeyfactorX509Store
    # Path to the root CA that signed the certificate passed to the client for HTTPS connection.
    # This is not required if the CA is trusted by the host operating system. This should be a PEM
    # formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
    attr_accessor :ca_file_path
    # Path to client certificate in PEM format. This certificate must contain a client certificate that
    # is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private
    # key associated with the certificate, but KeyFile can also be set to configure the private key.
    attr_accessor :certificate_file_path
    # Name of EJBCA certificate authority that will enroll CSR.
    attr_accessor :default_certificate_authority_name
    # Certificate profile name that EJBCA will enroll the CSR with.
    attr_accessor :default_certificate_profile_name
    # End entity profile that EJBCA will enroll the CSR with.
    attr_accessor :default_end_entity_profile_name
    # code used by EJBCA during enrollment. May be left blank if no code is required.
    attr_accessor :enrollment_code_env_var
    # username that used by the EJBCA during enrollment. This can be left out.
    # If so, the username must be auto-generated on the Keyfactor side.
    attr_accessor :enrollment_username_env_var
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Path to private key in PEM format. This file should contain the private key associated with the
    # client certificate configured in CertificateFile.
    attr_accessor :key_file_path
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # the host of the Key Factor CA
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_file_path: nil,
      certificate_file_path: nil,
      default_certificate_authority_name: nil,
      default_certificate_profile_name: nil,
      default_end_entity_profile_name: nil,
      enrollment_code_env_var: nil,
      enrollment_username_env_var: nil,
      id: nil,
      key_file_path: nil,
      name: nil,
      server_address: nil,
      tags: nil
    )
      @ca_file_path = ca_file_path == nil ? "" : ca_file_path
      @certificate_file_path = certificate_file_path == nil ? "" : certificate_file_path
      @default_certificate_authority_name = default_certificate_authority_name == nil ? "" : default_certificate_authority_name
      @default_certificate_profile_name = default_certificate_profile_name == nil ? "" : default_certificate_profile_name
      @default_end_entity_profile_name = default_end_entity_profile_name == nil ? "" : default_end_entity_profile_name
      @enrollment_code_env_var = enrollment_code_env_var == nil ? "" : enrollment_code_env_var
      @enrollment_username_env_var = enrollment_username_env_var == nil ? "" : enrollment_username_env_var
      @id = id == nil ? "" : id
      @key_file_path = key_file_path == nil ? "" : key_file_path
      @name = name == nil ? "" : name
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Kubernetes
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # KubernetesBasicAuth is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class KubernetesBasicAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccount
    # If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set)
    # when a resource role is not provided.
    attr_accessor :allow_resource_role_bypass
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # If true, configures discovery of a cluster to be run from a node.
    attr_accessor :discovery_enabled
    # If a cluster is configured for user impersonation, this is the user to impersonate when
    # running discovery.
    attr_accessor :discovery_username
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      allow_resource_role_bypass: nil,
      bind_interface: nil,
      discovery_enabled: nil,
      discovery_username: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @allow_resource_role_bypass = allow_resource_role_bypass == nil ? false : allow_resource_role_bypass
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @discovery_enabled = discovery_enabled == nil ? false : discovery_enabled
      @discovery_username = discovery_username == nil ? "" : discovery_username
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccountUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MTLSMysql is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MTLSMysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Server name for TLS verification (unverified by StrongDM if empty)
    attr_accessor :server_name
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      server_name: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MTLSPostgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Server name for TLS verification (unverified by StrongDM if empty)
    attr_accessor :server_name
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      server_name: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Maria
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memcached
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memsql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoHost
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoLegacyHost is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoLegacyHost
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoLegacyReplicaset is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoLegacyReplicaset
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Set to connect to a replica instead of the primary node.
    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoReplicaSet
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Set to connect to a replica instead of the primary node.
    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoShardedCluster
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Mysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Neptune
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class NeptuneIAM
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeCreateResponse reports how the Nodes were created in the system.
  class NodeCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Node. The Node will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil,
      token: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeDeleteResponse returns information about a Node that was deleted.
  class NodeDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeGetResponse returns a requested Node.
  class NodeGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeHistory records the state of a Node at a given point in time,
  # where every change (create, update and delete) to a Node produces an
  # NodeHistory record.
  class NodeHistory
    # The unique identifier of the Activity that produced this change to the Node.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Node was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Node state at this time.
    attr_accessor :node
    # The time at which the Node state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      node: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @node = node == nil ? nil : node
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class NodeMaintenanceWindow
    # Cron job syntax for when this maintenance window is active. On this schedule, associated
    # nodes will restart if requested, provided other checks allow the restart to proceed. Times
    # are represented in UTC.
    # e.g. * 7 * * 0,6 to check for a restart at every minute from 7:00 to 8:00 UTC on Sunday and
    # Saturday. Not all possible inputs are supported: the month and day of month selections
    # must be '*'.
    attr_accessor :cron_schedule
    # Require Idleness defines whether this window can sever live connections. If true,
    # this window will not allow a node to be restarted unless it is serving no connections.
    # If false, given a restart of the node has been requested (for an update, usually), the
    # node will restart as soon as it enters an allowed day / hour combination. At least one
    # maintenance window, out of all configured windows for a node, must have this as false.
    attr_accessor :require_idleness

    def initialize(
      cron_schedule: nil,
      require_idleness: nil
    )
      @cron_schedule = cron_schedule == nil ? "" : cron_schedule
      @require_idleness = require_idleness == nil ? false : require_idleness
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeUpdateResponse returns the fields of a Node after it has been updated by
  # a NodeUpdateRequest.
  class NodeUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The updated Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Oracle
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Organization
    # The Organization's authentication provider, one of the AuthProvider constants.
    attr_accessor :auth_provider
    # The time at which the Organization was created.
    attr_accessor :created_at
    # Indicates if the Organization has device trust enabled.
    attr_accessor :device_trust_enabled
    # The Organization's device trust provider, one of the DeviceTrustProvider constants.
    attr_accessor :device_trust_provider
    # Indicates if the Organization enforces a single session per user for the CLI and AdminUI.
    attr_accessor :enforce_single_session
    # The Organization's idle timeout, if enabled.
    attr_accessor :idle_timeout
    # Indicates if the Organization has idle timeouts enabled.
    attr_accessor :idle_timeout_enabled
    # The Organization's type, one of the OrgKind constants.
    attr_accessor :kind
    # The Organization's local log encryption encoder, one of the LogLocalEncoder constants.
    attr_accessor :log_local_encoder
    # The Organization's local log format, one of the LogLocalFormat constants.
    attr_accessor :log_local_format
    # The Organization's local log storage, one of the LogLocalStorage constants.
    attr_accessor :log_local_storage
    # The Organization's remote log encryption encoder, one of the LogRemoteEncoder constants.
    attr_accessor :log_remote_encoder
    # The Organization's socket path for Socket local log storage.
    attr_accessor :log_socket_path
    # The Organization's TCP address for TCP or Syslog local log storage.
    attr_accessor :log_tcp_address
    # The Organization's loopback range.
    attr_accessor :loopback_range
    # Indicates if the Organization has multi-factor authentication enabled.
    attr_accessor :mfa_enabled
    # The Organization's multi-factor authentication provider, one of the MFAProvider constants.
    attr_accessor :mfa_provider
    # The Organization's name.
    attr_accessor :name
    # Indicates if the Organization requires secret stores.
    attr_accessor :require_secret_store
    # The Organization's URL for SAML metadata.
    attr_accessor :saml_metadata_url
    # The Organization's SCIM provider, one of the SCIMProvider constants.
    attr_accessor :scim_provider
    # The Organization's label for sensitive resources.
    attr_accessor :sensitive_label
    # The Organization's session timeout, if enabled.
    attr_accessor :session_timeout
    # Indicates if the Organization has session timeouts enabled.
    attr_accessor :session_timeout_enabled
    # The Organization's SSH certificate authority public key.
    attr_accessor :ssh_certificate_authority_public_key
    # The time at which the Organization's SSH certificate authority was last updated.
    attr_accessor :ssh_certificate_authority_updated_at
    # The time at which the Organization was last updated.
    attr_accessor :updated_at
    # The Organization's web site domain.
    attr_accessor :websites_subdomain

    def initialize(
      auth_provider: nil,
      created_at: nil,
      device_trust_enabled: nil,
      device_trust_provider: nil,
      enforce_single_session: nil,
      idle_timeout: nil,
      idle_timeout_enabled: nil,
      kind: nil,
      log_local_encoder: nil,
      log_local_format: nil,
      log_local_storage: nil,
      log_remote_encoder: nil,
      log_socket_path: nil,
      log_tcp_address: nil,
      loopback_range: nil,
      mfa_enabled: nil,
      mfa_provider: nil,
      name: nil,
      require_secret_store: nil,
      saml_metadata_url: nil,
      scim_provider: nil,
      sensitive_label: nil,
      session_timeout: nil,
      session_timeout_enabled: nil,
      ssh_certificate_authority_public_key: nil,
      ssh_certificate_authority_updated_at: nil,
      updated_at: nil,
      websites_subdomain: nil
    )
      @auth_provider = auth_provider == nil ? "" : auth_provider
      @created_at = created_at == nil ? nil : created_at
      @device_trust_enabled = device_trust_enabled == nil ? false : device_trust_enabled
      @device_trust_provider = device_trust_provider == nil ? "" : device_trust_provider
      @enforce_single_session = enforce_single_session == nil ? false : enforce_single_session
      @idle_timeout = idle_timeout == nil ? nil : idle_timeout
      @idle_timeout_enabled = idle_timeout_enabled == nil ? false : idle_timeout_enabled
      @kind = kind == nil ? "" : kind
      @log_local_encoder = log_local_encoder == nil ? "" : log_local_encoder
      @log_local_format = log_local_format == nil ? "" : log_local_format
      @log_local_storage = log_local_storage == nil ? "" : log_local_storage
      @log_remote_encoder = log_remote_encoder == nil ? "" : log_remote_encoder
      @log_socket_path = log_socket_path == nil ? "" : log_socket_path
      @log_tcp_address = log_tcp_address == nil ? "" : log_tcp_address
      @loopback_range = loopback_range == nil ? "" : loopback_range
      @mfa_enabled = mfa_enabled == nil ? false : mfa_enabled
      @mfa_provider = mfa_provider == nil ? "" : mfa_provider
      @name = name == nil ? "" : name
      @require_secret_store = require_secret_store == nil ? false : require_secret_store
      @saml_metadata_url = saml_metadata_url == nil ? "" : saml_metadata_url
      @scim_provider = scim_provider == nil ? "" : scim_provider
      @sensitive_label = sensitive_label == nil ? "" : sensitive_label
      @session_timeout = session_timeout == nil ? nil : session_timeout
      @session_timeout_enabled = session_timeout_enabled == nil ? false : session_timeout_enabled
      @ssh_certificate_authority_public_key = ssh_certificate_authority_public_key == nil ? "" : ssh_certificate_authority_public_key
      @ssh_certificate_authority_updated_at = ssh_certificate_authority_updated_at == nil ? nil : ssh_certificate_authority_updated_at
      @updated_at = updated_at == nil ? nil : updated_at
      @websites_subdomain = websites_subdomain == nil ? "" : websites_subdomain
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # OrganizationHistoryRecord records the state of an Organization at a given point in time,
  # where every change to an Organization produces an OrganizationHistoryRecord.
  class OrganizationHistoryRecord
    # The unique identifier of the Activity that produced this change to the Organization.
    # May be empty for some system-initiated organization updates.
    attr_accessor :activity_id
    # The complete Organization state at this time.
    attr_accessor :organization
    # The time at which the Organization state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      organization: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @organization = organization == nil ? nil : organization
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroups are the building blocks used for explicit network topology making.
  # They may be linked to other peering groups. Sets of PeeringGroupResource and PeeringGroupNode can be attached to a peering group.
  class PeeringGroup
    # Unique identifier of the PeeringGroup.
    attr_accessor :id
    # Unique human-readable name of the PeeringGroup.
    attr_accessor :name

    def initialize(
      id: nil,
      name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupCreateResponse reports how the PeeringGroup was created in the system.
  class PeeringGroupCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroup.
    attr_accessor :peering_group
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group = peering_group == nil ? nil : peering_group
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupDeleteResponse returns information about a PeeringGroup that was deleted.
  class PeeringGroupDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupGetResponse returns a requested PeeringGroup.
  class PeeringGroupGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroup.
    attr_accessor :peering_group
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group = peering_group == nil ? nil : peering_group
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNode represents the attachment between a PeeringGroup and a Node.
  class PeeringGroupNode
    # Peering Group ID to which the node will be attached to.
    attr_accessor :group_id
    # Unique identifier of the Attachment.
    attr_accessor :id
    # Node ID to be attached.
    attr_accessor :node_id

    def initialize(
      group_id: nil,
      id: nil,
      node_id: nil
    )
      @group_id = group_id == nil ? "" : group_id
      @id = id == nil ? "" : id
      @node_id = node_id == nil ? "" : node_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNodeCreateResponse reports how the PeeringGroupNode was created in the system.
  class PeeringGroupNodeCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroupNode.
    attr_accessor :peering_group_node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_node = peering_group_node == nil ? nil : peering_group_node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNodeDeleteResponse returns information about a PeeringGroupNode that was deleted.
  class PeeringGroupNodeDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNodeGetResponse returns a requested PeeringGroupNode.
  class PeeringGroupNodeGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroupNode.
    attr_accessor :peering_group_node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_node = peering_group_node == nil ? nil : peering_group_node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeer represents the link between two PeeringGroups
  class PeeringGroupPeer
    # Group ID from which the link will originate.
    attr_accessor :group_id
    # Unique identifier of the Attachment.
    attr_accessor :id
    # Peering Group ID to which Group ID will link.
    attr_accessor :peers_with_group_id

    def initialize(
      group_id: nil,
      id: nil,
      peers_with_group_id: nil
    )
      @group_id = group_id == nil ? "" : group_id
      @id = id == nil ? "" : id
      @peers_with_group_id = peers_with_group_id == nil ? "" : peers_with_group_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeerCreateResponse reports how the PeeringGroupPeer was created in the system.
  class PeeringGroupPeerCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroupPeer.
    attr_accessor :peering_group_peer
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_peer: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_peer = peering_group_peer == nil ? nil : peering_group_peer
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeerDeleteResponse returns information about a PeeringGroupPeer that was deleted.
  class PeeringGroupPeerDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeerGetResponse returns a requested PeeringGroupPeer.
  class PeeringGroupPeerGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroupPeer.
    attr_accessor :peering_group_peer
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_peer: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_peer = peering_group_peer == nil ? nil : peering_group_peer
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResource represents the attachment between a PeeringGroup and a Resource.
  class PeeringGroupResource
    # Peering Group ID to which the resource will be attached to.
    attr_accessor :group_id
    # Unique identifier of the Attachment.
    attr_accessor :id
    # Resource ID to be attached.
    attr_accessor :resource_id

    def initialize(
      group_id: nil,
      id: nil,
      resource_id: nil
    )
      @group_id = group_id == nil ? "" : group_id
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResourceCreateResponse reports how the attachment was created in the system.
  class PeeringGroupResourceCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroupResource.
    attr_accessor :peering_group_resource
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_resource: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_resource = peering_group_resource == nil ? nil : peering_group_resource
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResourceDeleteResponse returns information about a PeeringGroupResource that was deleted.
  class PeeringGroupResourceDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResourceGetResponse returns a requested PeeringGroupResource.
  class PeeringGroupResourceGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroupResource.
    attr_accessor :peering_group_resource
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_resource: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_resource = peering_group_resource == nil ? nil : peering_group_resource
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Policy is a collection of one or more statements that enforce fine-grained access control
  # for the users of an organization.
  class Policy
    # Optional description of the Policy.
    attr_accessor :description
    # Unique identifier of the Policy.
    attr_accessor :id
    # Unique human-readable name of the Policy.
    attr_accessor :name
    # The content of the Policy, in Cedar policy language.
    attr_accessor :policy

    def initialize(
      description: nil,
      id: nil,
      name: nil,
      policy: nil
    )
      @description = description == nil ? "" : description
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @policy = policy == nil ? "" : policy
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PolicyCreateResponse reports how the Policy was created in the system.
  class PolicyCreateResponse
    # The created Policy.
    attr_accessor :policy
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      policy: nil,
      rate_limit: nil
    )
      @policy = policy == nil ? nil : policy
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PolicyDeleteResponse returns information about a Policy that was deleted.
  class PolicyDeleteResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PolicyGetResponse returns a requested Policy.
  class PolicyGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested Policy.
    attr_accessor :policy
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      policy: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @policy = policy == nil ? nil : policy
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PolicyHistory records the state of a Policy at a given point in time,
  # where every change (create, update and delete) to a Policy produces a
  # PolicyHistory record.
  class PolicyHistory
    # The unique identifier of the Activity that produced this change to the Policy.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Policy was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Policy state at this time.
    attr_accessor :policy
    # The time at which the Policy state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      policy: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @policy = policy == nil ? nil : policy
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PolicyListResponse returns a list of Policy records that meet
  # the criteria of a PolicyListRequest.
  class PolicyListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PolicyUpdateResponse returns the fields of a Policy after it has been updated by
  # a PolicyUpdateRequest.
  class PolicyUpdateResponse
    # The updated Policy.
    attr_accessor :policy
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      policy: nil,
      rate_limit: nil
    )
      @policy = policy == nil ? nil : policy
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Postgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Presto
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ProxyCluster represents a cluster of StrongDM proxies.
  class ProxyCluster
    # The public hostname/port tuple at which the proxy cluster will be
    # accessible to clients.
    attr_accessor :address
    # Unique identifier of the Proxy Cluster.
    attr_accessor :id
    # Maintenance Windows define when this node is allowed to restart. If a node
    # is requested to restart, it will check each window to determine if any of
    # them permit it to restart, and if any do, it will. This check is repeated
    # per window until the restart is successfully completed.
    #
    # If not set here, may be set on the command line or via an environment variable
    # on the process itself; any server setting will take precedence over local
    # settings. This setting is ineffective for nodes below version 38.44.0.
    #
    # If this setting is not applied via this remote configuration or via local
    # configuration, the default setting is used: always allow restarts if serving
    # no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
    attr_accessor :maintenance_windows
    # Unique human-readable name of the proxy cluster. Names must
    # include only letters, numbers, and hyphens (no spaces, underscores, or
    # other special characters). Generated if not provided on create.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      address: nil,
      id: nil,
      maintenance_windows: nil,
      name: nil,
      tags: nil
    )
      @address = address == nil ? "" : address
      @id = id == nil ? "" : id
      @maintenance_windows = maintenance_windows == nil ? [] : maintenance_windows
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Proxy Cluster Keys are authentication keys for all proxies within a cluster.
  # The proxies within a cluster share the same key. One cluster can have
  # multiple keys in order to facilitate key rotation.
  class ProxyClusterKey
    # The timestamp when this key was created.
    attr_accessor :created_at
    # Unique identifier of the Relay.
    attr_accessor :id
    # The timestamp when this key was last used, if at all.
    attr_accessor :last_used_at
    # The ID of the proxy cluster which this key authenticates to.
    attr_accessor :proxy_cluster_id

    def initialize(
      created_at: nil,
      id: nil,
      last_used_at: nil,
      proxy_cluster_id: nil
    )
      @created_at = created_at == nil ? nil : created_at
      @id = id == nil ? "" : id
      @last_used_at = last_used_at == nil ? nil : last_used_at
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ProxyClusterKeyCreateResponse reports how the ProxyClusterKeys were created in the system.
  class ProxyClusterKeyCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created ProxyClusterKey.
    attr_accessor :proxy_cluster_key
    # Rate limit information.
    attr_accessor :rate_limit
    # The secret key component of this key. It must be saved upon creation
    # because it will not be available for retrieval later.
    attr_accessor :secret_key

    def initialize(
      meta: nil,
      proxy_cluster_key: nil,
      rate_limit: nil,
      secret_key: nil
    )
      @meta = meta == nil ? nil : meta
      @proxy_cluster_key = proxy_cluster_key == nil ? nil : proxy_cluster_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_key = secret_key == nil ? "" : secret_key
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ProxyClusterKeyDeleteResponse returns information about a ProxyClusterKey that was deleted.
  class ProxyClusterKeyDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ProxyClusterKeyGetResponse returns a requested ProxyClusterKey.
  class ProxyClusterKeyGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested ProxyClusterKey.
    attr_accessor :proxy_cluster_key
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      proxy_cluster_key: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @proxy_cluster_key = proxy_cluster_key == nil ? nil : proxy_cluster_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Query is a record of a single client request to a resource, such as a SQL query.
  # Longer-running queries including long-running SSH commands and SSH, RDP, or Kubernetes
  # interactive sessions will return two Query records with the same identifier, one record
  # at the start of the query and a second record upon the completion of the query with
  # additional detail.
  class Query
    # The email of the account performing this query, at the time the query was executed.
    # If the account email is later changed, that change will not be reflected via this field.
    attr_accessor :account_email
    # The given name of the account performing this query, at the time the query was executed.
    # If the account is later renamed, that change will not be reflected via this field.
    attr_accessor :account_first_name
    # Unique identifier of the Account that performed the Query.
    attr_accessor :account_id
    # The family name of the account performing this query, at the time the query was executed.
    # If the account is later renamed, that change will not be reflected via this field.
    attr_accessor :account_last_name
    # The tags of the account accessed, at the time the query was executed. If the account
    # tags are later changed, that change will not be reflected via this field.
    attr_accessor :account_tags
    # Authorization metadata associated with this query.
    attr_accessor :authzjson
    # For queries against SSH, Kubernetes, and RDP resources, this contains additional information
    # about the captured query.
    attr_accessor :capture
    # The IP address the Query was performed from, as detected at the StrongDM control plane.
    attr_accessor :client_ip
    # The time at which the Query was completed.
    # Empty if this record indicates the start of a long-running query.
    attr_accessor :completed_at
    # The duration of the Query.
    attr_accessor :duration
    # The unique ID of the node through which the Resource was accessed.
    attr_accessor :egress_node_id
    # Indicates that the body of the Query is encrypted.
    attr_accessor :encrypted
    # Unique identifier of the Query.
    attr_accessor :id
    # The username of the IdentityAlias used to access the Resource.
    attr_accessor :identity_alias_username
    # The captured content of the Query.
    # For queries against SSH, Kubernetes, and RDP resources, this contains a JSON representation of the QueryCapture.
    attr_accessor :query_body
    # The general category of Resource against which Query was performed, e.g. "web" or "cloud".
    attr_accessor :query_category
    # The hash of the body of the Query.
    attr_accessor :query_hash
    # The symmetric key used to encrypt the body of this Query and its replay if replayable.
    # If the Query is encrypted, this field contains an encrypted symmetric key in base64 encoding.
    # This key must be decrypted with the organization's private key to obtain the symmetric key needed to decrypt the body.
    # If the Query is not encrypted, this field is empty.
    attr_accessor :query_key
    # The number of records returned by the Query, for a database Resource.
    attr_accessor :record_count
    # The username of the RemoteIdentity used to access the Resource.
    attr_accessor :remote_identity_username
    # Indicates that the Query is replayable, e.g. for some SSH or K8s sessions.
    attr_accessor :replayable
    # Unique identifier of the Resource against which the Query was performed.
    attr_accessor :resource_id
    # The name of the resource accessed, at the time the query was executed. If the resource
    # is later renamed, that change will not be reflected via this field.
    attr_accessor :resource_name
    # The tags of the resource accessed, at the time the query was executed. If the resource
    # tags are later changed, that change will not be reflected via this field.
    attr_accessor :resource_tags
    # The specific type of Resource against which the Query was performed, e.g. "ssh" or "postgres".
    attr_accessor :resource_type
    # The IP address the Query was performed from, as detected at the ingress gateway.
    attr_accessor :source_ip
    # The target destination of the query, in host:port format.
    attr_accessor :target
    # The time at which the Query was started.
    attr_accessor :timestamp

    def initialize(
      account_email: nil,
      account_first_name: nil,
      account_id: nil,
      account_last_name: nil,
      account_tags: nil,
      authzjson: nil,
      capture: nil,
      client_ip: nil,
      completed_at: nil,
      duration: nil,
      egress_node_id: nil,
      encrypted: nil,
      id: nil,
      identity_alias_username: nil,
      query_body: nil,
      query_category: nil,
      query_hash: nil,
      query_key: nil,
      record_count: nil,
      remote_identity_username: nil,
      replayable: nil,
      resource_id: nil,
      resource_name: nil,
      resource_tags: nil,
      resource_type: nil,
      source_ip: nil,
      target: nil,
      timestamp: nil
    )
      @account_email = account_email == nil ? "" : account_email
      @account_first_name = account_first_name == nil ? "" : account_first_name
      @account_id = account_id == nil ? "" : account_id
      @account_last_name = account_last_name == nil ? "" : account_last_name
      @account_tags = account_tags == nil ? SDM::_porcelain_zero_value_tags() : account_tags
      @authzjson = authzjson == nil ? "" : authzjson
      @capture = capture == nil ? nil : capture
      @client_ip = client_ip == nil ? "" : client_ip
      @completed_at = completed_at == nil ? nil : completed_at
      @duration = duration == nil ? nil : duration
      @egress_node_id = egress_node_id == nil ? "" : egress_node_id
      @encrypted = encrypted == nil ? false : encrypted
      @id = id == nil ? "" : id
      @identity_alias_username = identity_alias_username == nil ? "" : identity_alias_username
      @query_body = query_body == nil ? "" : query_body
      @query_category = query_category == nil ? "" : query_category
      @query_hash = query_hash == nil ? "" : query_hash
      @query_key = query_key == nil ? "" : query_key
      @record_count = record_count == nil ? 0 : record_count
      @remote_identity_username = remote_identity_username == nil ? "" : remote_identity_username
      @replayable = replayable == nil ? false : replayable
      @resource_id = resource_id == nil ? "" : resource_id
      @resource_name = resource_name == nil ? "" : resource_name
      @resource_tags = resource_tags == nil ? SDM::_porcelain_zero_value_tags() : resource_tags
      @resource_type = resource_type == nil ? "" : resource_type
      @source_ip = source_ip == nil ? "" : source_ip
      @target = target == nil ? "" : target
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A QueryCapture contains additional information about queries against SSH, Kubernetes, and RDP resources.
  class QueryCapture
    # The command executed on the client for a Kubernetes session.
    attr_accessor :client_command
    # The command executed over an SSH or Kubernetes session.
    attr_accessor :command
    # The target container of a Kubernetes operation.
    attr_accessor :container
    # The environment variables for an SSH or Kubernetes session.
    attr_accessor :env
    # The remote file name of an SCP operation.
    attr_accessor :file_name
    # The file size transferred for an SCP operation.
    attr_accessor :file_size
    # The height of the terminal or window for SSH, Kubernetes, and RDP interactive sessions.
    attr_accessor :height
    # The impersonation groups of a Kubernetes operation.
    attr_accessor :impersonation_groups
    # The impersonation user of a Kubernetes operation.
    attr_accessor :impersonation_user
    # The target pod of a Kubernetes operation.
    attr_accessor :pod
    # The HTTP request body of a Kubernetes operation.
    attr_accessor :request_body
    # The HTTP request method of a Kubernetes operation.
    attr_accessor :request_method
    # The HTTP request URI of a Kubernetes operation.
    attr_accessor :request_uri
    # The CaptureType of this query capture, one of the CaptureType constants.
    attr_accessor :type
    # The width of the terminal or window for SSH, Kubernetes, and RDP interactive sessions.
    attr_accessor :width

    def initialize(
      client_command: nil,
      command: nil,
      container: nil,
      env: nil,
      file_name: nil,
      file_size: nil,
      height: nil,
      impersonation_groups: nil,
      impersonation_user: nil,
      pod: nil,
      request_body: nil,
      request_method: nil,
      request_uri: nil,
      type: nil,
      width: nil
    )
      @client_command = client_command == nil ? "" : client_command
      @command = command == nil ? "" : command
      @container = container == nil ? "" : container
      @env = env == nil ? {} : env
      @file_name = file_name == nil ? "" : file_name
      @file_size = file_size == nil ? 0 : file_size
      @height = height == nil ? 0 : height
      @impersonation_groups = impersonation_groups == nil ? [] : impersonation_groups
      @impersonation_user = impersonation_user == nil ? "" : impersonation_user
      @pod = pod == nil ? "" : pod
      @request_body = request_body == nil ? "" : request_body
      @request_method = request_method == nil ? "" : request_method
      @request_uri = request_uri == nil ? "" : request_uri
      @type = type == nil ? "" : type
      @width = width == nil ? 0 : width
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RDP
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
    attr_accessor :downgrade_nla_connections
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
    attr_accessor :lock_required
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      downgrade_nla_connections: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      lock_required: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @downgrade_nla_connections = downgrade_nla_connections == nil ? false : downgrade_nla_connections
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @lock_required = lock_required == nil ? false : lock_required
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RDPCert
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RDSPostgresIAM
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The AWS region to connect to.
    attr_accessor :region
    # If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
    attr_accessor :role_assumption_arn
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      region: nil,
      role_assumption_arn: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @region = region == nil ? "" : region
      @role_assumption_arn = role_assumption_arn == nil ? "" : role_assumption_arn
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RabbitMQAMQP091
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RateLimitMetadata contains information about remaining requests avaialable
  # to the user over some timeframe.
  class RateLimitMetadata
    # The bucket this user/token is associated with, which may be shared between
    # multiple users/tokens.
    attr_accessor :bucket
    # How many total requests the user/token is authorized to make before being
    # rate limited.
    attr_accessor :limit
    # How many remaining requests out of the limit are still avaialable.
    attr_accessor :remaining
    # The time when remaining will be reset to limit.
    attr_accessor :reset_at

    def initialize(
      bucket: nil,
      limit: nil,
      remaining: nil,
      reset_at: nil
    )
      @bucket = bucket == nil ? "" : bucket
      @limit = limit == nil ? 0 : limit
      @remaining = remaining == nil ? 0 : remaining
      @reset_at = reset_at == nil ? nil : reset_at
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RawTCP
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redis
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redshift
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Relay represents a StrongDM CLI installation running in relay mode.
  class Relay
    # Device is a read only device name uploaded by the gateway process when
    # it comes online.
    attr_accessor :device
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways. Deprecated.
    attr_accessor :gateway_filter
    # Unique identifier of the Relay.
    attr_accessor :id
    # Location is a read only network location uploaded by the gateway process
    # when it comes online.
    attr_accessor :location
    # Maintenance Windows define when this node is allowed to restart. If a node
    # is requested to restart, it will check each window to determine if any of
    # them permit it to restart, and if any do, it will. This check is repeated
    # per window until the restart is successfully completed.
    #
    # If not set here, may be set on the command line or via an environment variable
    # on the process itself; any server setting will take precedence over local
    # settings. This setting is ineffective for nodes below version 38.44.0.
    #
    # If this setting is not applied via this remote configuration or via local
    # configuration, the default setting is used: always allow restarts if serving
    # no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
    attr_accessor :maintenance_windows
    # Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the relay, one of the NodeState constants.
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # Version is a read only sdm binary version uploaded by the gateway process
    # when it comes online.
    attr_accessor :version

    def initialize(
      device: nil,
      gateway_filter: nil,
      id: nil,
      location: nil,
      maintenance_windows: nil,
      name: nil,
      state: nil,
      tags: nil,
      version: nil
    )
      @device = device == nil ? "" : device
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @location = location == nil ? "" : location
      @maintenance_windows = maintenance_windows == nil ? [] : maintenance_windows
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @version = version == nil ? "" : version
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentities define the username to be used for a specific account
  # when connecting to a remote resource using that group.
  class RemoteIdentity
    # The account for this remote identity.
    attr_accessor :account_id
    # Unique identifier of the RemoteIdentity.
    attr_accessor :id
    # The remote identity group.
    attr_accessor :remote_identity_group_id
    # The username to be used as the remote identity for this account.
    attr_accessor :username

    def initialize(
      account_id: nil,
      id: nil,
      remote_identity_group_id: nil,
      username: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityCreateResponse reports how the RemoteIdentities were created in the system.
  class RemoteIdentityCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityDeleteResponse returns information about a RemoteIdentity that was deleted.
  class RemoteIdentityDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGetResponse returns a requested RemoteIdentity.
  class RemoteIdentityGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A RemoteIdentityGroup defines a group of remote identities.
  class RemoteIdentityGroup
    # Unique identifier of the RemoteIdentityGroup.
    attr_accessor :id
    # Unique human-readable name of the RemoteIdentityGroup.
    attr_accessor :name

    def initialize(
      id: nil,
      name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGroupGetResponse returns a requested RemoteIdentityGroup.
  class RemoteIdentityGroupGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RemoteIdentityGroup.
    attr_accessor :remote_identity_group

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity_group: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity_group = remote_identity_group == nil ? nil : remote_identity_group
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGroupHistory records the state of a RemoteIdentityGroup at a given point in time,
  # where every change (create, update and delete) to a RemoteIdentityGroup produces an
  # RemoteIdentityGroupHistory record.
  class RemoteIdentityGroupHistory
    # The unique identifier of the Activity that produced this change to the RemoteIdentityGroup.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RemoteIdentityGroup was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RemoteIdentityGroup state at this time.
    attr_accessor :remote_identity_group
    # The time at which the RemoteIdentityGroup state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      remote_identity_group: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @remote_identity_group = remote_identity_group == nil ? nil : remote_identity_group
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityHistory records the state of a RemoteIdentity at a given point in time,
  # where every change (create, update and delete) to a RemoteIdentity produces an
  # RemoteIdentityHistory record.
  class RemoteIdentityHistory
    # The unique identifier of the Activity that produced this change to the RemoteIdentity.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RemoteIdentity was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RemoteIdentity state at this time.
    attr_accessor :remote_identity
    # The time at which the RemoteIdentity state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      remote_identity: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @remote_identity = remote_identity == nil ? nil : remote_identity
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityUpdateResponse returns the fields of a RemoteIdentity after it has been updated by
  # a RemoteIdentityUpdateRequest.
  class RemoteIdentityUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A ReplayChunk represents a single "chunk" of data from the query replay.
  class ReplayChunk
    # The raw data of the ReplayChunk. The data is encrypted if the associated Query is encrypted.
    attr_accessor :data
    # The list of events of the ReplayChunk. If the Query is encrypted, this field is always empty
    # and the events can be obtained by decrypting the data using the QueryKey returned with the Query.
    attr_accessor :events

    def initialize(
      data: nil,
      events: nil
    )
      @data = data == nil ? "" : data
      @events = events == nil ? [] : events
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A ReplayChunkEvent represents a single event within a query replay.
  # The timing information included in each ReplayChunkEvent may be used to replay a session in real time.
  class ReplayChunkEvent
    # The raw data of the ReplayChunkEvent.
    attr_accessor :data
    # The time duration over which the data in this ReplayChunkEvent was transferred.
    attr_accessor :duration

    def initialize(
      data: nil,
      duration: nil
    )
      @data = data == nil ? "" : data
      @duration = duration == nil ? nil : duration
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RequestableResource is a resource that can be requested via an AccessRequestConfig
  class RequestableResource
    # The current state of the user's access to the resources
    attr_accessor :access
    # The type of authentication for the resource
    attr_accessor :authentication
    # The health check status of the reasource
    attr_accessor :healthy
    # The resource id.
    attr_accessor :id
    # The resource name.
    attr_accessor :name
    # Any tags attached to this resource
    attr_accessor :tags
    # The resource type
    attr_accessor :type

    def initialize(
      access: nil,
      authentication: nil,
      healthy: nil,
      id: nil,
      name: nil,
      tags: nil,
      type: nil
    )
      @access = access == nil ? "" : access
      @authentication = authentication == nil ? "" : authentication
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @type = type == nil ? "" : type
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceCreateResponse reports how the Resources were created in the system.
  class ResourceCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceDeleteResponse returns information about a Resource that was deleted.
  class ResourceDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceGetResponse returns a requested Resource.
  class ResourceGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceHealthcheckRequest specifies requesting a healthcheck for a given resource by ID.
  class ResourceHealthcheckRequest
    # The unique identifier of the Resource to healthcheck.
    attr_accessor :id

    def initialize(
      id: nil
    )
      @id = id == nil ? "" : id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceHealthcheckResponse reports any metadata concerning a healthcheck response.
  # Healthchecks are non blocking, and this contains no non-metadata.
  class ResourceHealthcheckResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceHistory records the state of a Resource at a given point in time,
  # where every change (create, update and delete) to a Resource produces an
  # ResourceHistory record.
  class ResourceHistory
    # The unique identifier of the Activity that produced this change to the Resource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Resource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Resource state at this time.
    attr_accessor :resource
    # The time at which the Resource state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      resource: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @resource = resource == nil ? nil : resource
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceUpdateResponse returns the fields of a Resource after it has been updated by
  # a ResourceUpdateRequest.
  class ResourceUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Role has a list of access rules which determine which Resources the members
  # of the Role have access to. An Account can be a member of multiple Roles via
  # AccountAttachments.
  class Role
    # AccessRules is a list of access rules defining the resources this Role has access to.
    attr_accessor :access_rules
    # Unique identifier of the Role.
    attr_accessor :id
    # Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
    attr_accessor :managed_by
    # Unique human-readable name of the Role.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_rules: nil,
      id: nil,
      managed_by: nil,
      name: nil,
      tags: nil
    )
      @access_rules = access_rules == nil ? SDM::_porcelain_zero_value_access_rules() : access_rules
      @id = id == nil ? "" : id
      @managed_by = managed_by == nil ? "" : managed_by
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleCreateResponse reports how the Roles were created in the system. It can
  # communicate partial successes or failures.
  class RoleCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleDeleteResponse returns information about a Role that was deleted.
  class RoleDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGetResponse returns a requested Role.
  class RoleGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleHistory records the state of a Role at a given point in time,
  # where every change (create, update and delete) to a Role produces an
  # RoleHistory record.
  class RoleHistory
    # The unique identifier of the Activity that produced this change to the Role.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Role was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Role state at this time.
    attr_accessor :role
    # The time at which the Role state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      role: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @role = role == nil ? nil : role
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleResource represents an individual access grant of a Role to a Resource.
  class RoleResource
    # The most recent time at which access was granted. If access was granted,
    # revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The unique identifier of the Resource to which access is granted.
    attr_accessor :resource_id
    # The unique identifier of the Role to which access is granted.
    attr_accessor :role_id

    def initialize(
      granted_at: nil,
      resource_id: nil,
      role_id: nil
    )
      @granted_at = granted_at == nil ? nil : granted_at
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleResourceHistory records the state of a RoleResource at a given point in time,
  # where every change (create or delete) to a RoleResource produces an
  # RoleResourceHistory record.
  class RoleResourceHistory
    # The unique identifier of the Activity that produced this change to the RoleResource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RoleResource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RoleResource state at this time.
    attr_accessor :role_resource
    # The time at which the RoleResource state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      role_resource: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @role_resource = role_resource == nil ? nil : role_resource
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleUpdateResponse returns the fields of a Role after it has been updated by
  # a RoleUpdateRequest.
  class RoleUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServer
    # Whether to allow deprecated encryption protocols to be used for this resource. For example,
    # TLS 1.0.
    attr_accessor :allow_deprecated_encryption
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks, and used for clients if Override Default Database is true.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The Schema to use to direct initial requests.
    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_encryption: nil,
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      schema: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_encryption = allow_deprecated_encryption == nil ? false : allow_deprecated_encryption
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServerAzureAD
    # Whether to allow deprecated encryption protocols to be used for this resource. For example,
    # TLS 1.0.
    attr_accessor :allow_deprecated_encryption
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The Azure AD application (client) ID with which to authenticate.
    attr_accessor :client_id
    # The database for healthchecks, and used for clients if Override Default Database is true.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The Schema to use to direct initial requests.
    attr_accessor :schema
    # The Azure AD client secret (application password) with which to authenticate.
    attr_accessor :secret
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The Azure AD directory (tenant) ID with which to authenticate.
    attr_accessor :tenant_id

    def initialize(
      allow_deprecated_encryption: nil,
      bind_interface: nil,
      client_id: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      schema: nil,
      secret: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @allow_deprecated_encryption = allow_deprecated_encryption == nil ? false : allow_deprecated_encryption
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @client_id = client_id == nil ? "" : client_id
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @schema = schema == nil ? "" : schema
      @secret = secret == nil ? "" : secret
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServerKerberosAD
    # Whether to allow deprecated encryption protocols to be used for this resource. For example,
    # TLS 1.0.
    attr_accessor :allow_deprecated_encryption
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks, and used for clients if Override Default Database is true.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
    attr_accessor :keytab
    # The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
    attr_accessor :krb_config
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The Active Directory domain (realm) to which the configured username belongs.
    attr_accessor :realm
    # The Schema to use to direct initial requests.
    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
    attr_accessor :server_spn
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_encryption: nil,
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      keytab: nil,
      krb_config: nil,
      name: nil,
      override_database: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      realm: nil,
      schema: nil,
      secret_store_id: nil,
      server_spn: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_encryption = allow_deprecated_encryption == nil ? false : allow_deprecated_encryption
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @keytab = keytab == nil ? "" : keytab
      @krb_config = krb_config == nil ? "" : krb_config
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @realm = realm == nil ? "" : realm
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_spn = server_spn == nil ? "" : server_spn
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSH
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The key type to use e.g. rsa-2048 or ed25519
    attr_accessor :key_type
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The public key to append to a server's authorized keys. This will be generated after resource creation.
    attr_accessor :public_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      key_type: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      public_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @key_type = key_type == nil ? "" : key_type
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @public_key = public_key == nil ? "" : public_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCert
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
    attr_accessor :identity_alias_healthcheck_username
    # The ID of the identity set to use for identity connections.
    attr_accessor :identity_set_id
    # The key type to use e.g. rsa-2048 or ed25519
    attr_accessor :key_type
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      identity_alias_healthcheck_username: nil,
      identity_set_id: nil,
      key_type: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @identity_alias_healthcheck_username = identity_alias_healthcheck_username == nil ? "" : identity_alias_healthcheck_username
      @identity_set_id = identity_set_id == nil ? "" : identity_set_id
      @key_type = key_type == nil ? "" : key_type
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCustomerKey
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The private key used to authenticate with the server.
    attr_accessor :private_key
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      private_key: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHPassword
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreCreateResponse reports how the SecretStores were created in the system.
  class SecretStoreCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreDeleteResponse returns information about a SecretStore that was deleted.
  class SecretStoreDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreGetResponse returns a requested SecretStore.
  class SecretStoreGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreHealth denotes a secret store's health status. Note a secret store is not
  # healthy in terms of a simple boolean, but rather healthy with respect to a particular node
  # or set of nodes.
  class SecretStoreHealth
    # The time when the status last changed
    attr_accessor :changed_at
    # The time when the status was last checked by the node
    attr_accessor :checked_at
    # The error associated with this health check, if it occurred after reachability checks succeeded.
    attr_accessor :error
    # Any specific status or error flags associated with this health check.
    attr_accessor :flags
    # Associated node id for this health
    attr_accessor :node_id
    # The error associated with this health check, if it occurred during reachability checks.
    attr_accessor :reachability
    # Associated secret store for this health
    attr_accessor :secret_store_id
    # The status of the link between the node and secret store
    attr_accessor :status

    def initialize(
      changed_at: nil,
      checked_at: nil,
      error: nil,
      flags: nil,
      node_id: nil,
      reachability: nil,
      secret_store_id: nil,
      status: nil
    )
      @changed_at = changed_at == nil ? nil : changed_at
      @checked_at = checked_at == nil ? nil : checked_at
      @error = error == nil ? "" : error
      @flags = flags == nil ? [] : flags
      @node_id = node_id == nil ? "" : node_id
      @reachability = reachability == nil ? "" : reachability
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @status = status == nil ? "" : status
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SecretStoreHealthListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SecretStoreHealthcheckResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreHistory records the state of a SecretStore at a given point in time,
  # where every change (create, update and delete) to a SecretStore produces an
  # SecretStoreHistory record.
  class SecretStoreHistory
    # The unique identifier of the Activity that produced this change to the SecretStore.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this SecretStore was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete SecretStore state at this time.
    attr_accessor :secret_store
    # The time at which the SecretStore state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      secret_store: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @secret_store = secret_store == nil ? nil : secret_store
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreUpdateResponse returns the fields of a SecretStore after it has been updated by
  # a SecretStoreUpdateRequest.
  class SecretStoreUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Service is a service account that can connect to resources they are granted
  # directly, or granted via roles. Services are typically automated jobs.
  class Service
    # Unique identifier of the Service.
    attr_accessor :id
    # Unique human-readable name of the Service.
    attr_accessor :name
    # The Service's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      suspended: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SingleStore
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Snowflake
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The schema to provide on authentication.
    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      schema: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Snowsight
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The StrongDM user email to use for healthchecks.
    attr_accessor :healthcheck_username
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # The Metadata for your snowflake IDP integration
    attr_accessor :samlmetadata
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_username: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      samlmetadata: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_username = healthcheck_username == nil ? "" : healthcheck_username
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @samlmetadata = samlmetadata == nil ? "" : samlmetadata
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Sybase
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SybaseIQ
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Tag
    # The name or key of this tag. Each name can only refer to one value on a tagged entity.
    attr_accessor :name
    # The value of this tag.
    attr_accessor :value

    def initialize(
      name: nil,
      value: nil
    )
      @name = name == nil ? "" : name
      @value = value == nil ? "" : value
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Teradata
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Token is an account providing tokenized access for automation or integration use.
  # Tokens include admin tokens, API keys, and SCIM tokens.
  class Token
    # Corresponds to the type of token, e.g. api or admin-token.
    attr_accessor :account_type
    # The timestamp when the Token will expire.
    attr_accessor :deadline
    # Duration from token creation to expiration.
    attr_accessor :duration
    # Unique identifier of the Token.
    attr_accessor :id
    # Unique human-readable name of the Token.
    attr_accessor :name
    # Permissions assigned to the token, e.g. role:create.
    attr_accessor :permissions
    # The timestamp when the Token was last rekeyed.
    attr_accessor :rekeyed
    # Reserved for future use.  Always false for tokens.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      account_type: nil,
      deadline: nil,
      duration: nil,
      id: nil,
      name: nil,
      permissions: nil,
      rekeyed: nil,
      suspended: nil,
      tags: nil
    )
      @account_type = account_type == nil ? "" : account_type
      @deadline = deadline == nil ? nil : deadline
      @duration = duration == nil ? nil : duration
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @permissions = permissions == nil ? [] : permissions
      @rekeyed = rekeyed == nil ? nil : rekeyed
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Trino is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class Trino
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the proxy cluster for this resource, if any.
    attr_accessor :proxy_cluster_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      proxy_cluster_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @proxy_cluster_id = proxy_cluster_id == nil ? "" : proxy_cluster_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # UpdateResponseMetadata is reserved for future use.
  class UpdateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A User can connect to resources they are granted directly, or granted
  # via roles.
  class User
    # The User's email address. Must be unique.
    attr_accessor :email
    # External ID is an alternative unique ID this user is represented by within an external service.
    attr_accessor :external_id
    # The User's first name.
    attr_accessor :first_name
    # Unique identifier of the User.
    attr_accessor :id
    # The User's last name.
    attr_accessor :last_name
    # Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
    attr_accessor :managed_by
    # Password is a write-only field that can be used to set the user's password.
    # Currently only supported for update.
    attr_accessor :password
    # PermissionLevel is the user's permission level e.g. admin, DBA, user.
    attr_accessor :permission_level
    # Suspended is a read only field for the User's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      email: nil,
      external_id: nil,
      first_name: nil,
      id: nil,
      last_name: nil,
      managed_by: nil,
      password: nil,
      permission_level: nil,
      suspended: nil,
      tags: nil
    )
      @email = email == nil ? "" : email
      @external_id = external_id == nil ? "" : external_id
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
      @managed_by = managed_by == nil ? "" : managed_by
      @password = password == nil ? "" : password
      @permission_level = permission_level == nil ? "" : permission_level
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # VaultAWSEC2Store is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class VaultAWSEC2Store
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # VaultAWSIAMStore is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class VaultAWSIAMStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultAppRoleCertSSHStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA represented in minutes.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # The signing role to be used for signing certificates
    attr_accessor :signing_role
    # The mount point of the SSH engine configured with the desired CA
    attr_accessor :ssh_mount_point
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      signing_role: nil,
      ssh_mount_point: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @signing_role = signing_role == nil ? "" : signing_role
      @ssh_mount_point = ssh_mount_point == nil ? "" : ssh_mount_point
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultAppRoleCertX509Store
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA in minutes. Recommended value is 5.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The mount point of the PKI engine configured with the desired CA
    attr_accessor :pki_mount_point
    # The URL of the Vault to target
    attr_accessor :server_address
    # The signing role to be used for signing certificates
    attr_accessor :signing_role
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      namespace: nil,
      pki_mount_point: nil,
      server_address: nil,
      signing_role: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @pki_mount_point = pki_mount_point == nil ? "" : pki_mount_point
      @server_address = server_address == nil ? "" : server_address
      @signing_role = signing_role == nil ? "" : signing_role
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultAppRoleStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTLSCertSSHStore
    # A path to a CA file accessible by a Node
    attr_accessor :ca_cert_path
    # A path to a client certificate file accessible by a Node
    attr_accessor :client_cert_path
    # A path to a client key file accessible by a Node
    attr_accessor :client_key_path
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA represented in minutes.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # The signing role to be used for signing certificates
    attr_accessor :signing_role
    # The mount point of the SSH engine configured with the desired CA
    attr_accessor :ssh_mount_point
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_cert_path: nil,
      client_cert_path: nil,
      client_key_path: nil,
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      signing_role: nil,
      ssh_mount_point: nil,
      tags: nil
    )
      @ca_cert_path = ca_cert_path == nil ? "" : ca_cert_path
      @client_cert_path = client_cert_path == nil ? "" : client_cert_path
      @client_key_path = client_key_path == nil ? "" : client_key_path
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @signing_role = signing_role == nil ? "" : signing_role
      @ssh_mount_point = ssh_mount_point == nil ? "" : ssh_mount_point
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTLSCertX509Store
    # A path to a CA file accessible by a Node
    attr_accessor :ca_cert_path
    # A path to a client certificate file accessible by a Node
    attr_accessor :client_cert_path
    # A path to a client key file accessible by a Node
    attr_accessor :client_key_path
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA represented in minutes.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The mount point of the PKI engine configured with the desired CA
    attr_accessor :pki_mount_point
    # The URL of the Vault to target
    attr_accessor :server_address
    # The signing role to be used for signing certificates
    attr_accessor :signing_role
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_cert_path: nil,
      client_cert_path: nil,
      client_key_path: nil,
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      namespace: nil,
      pki_mount_point: nil,
      server_address: nil,
      signing_role: nil,
      tags: nil
    )
      @ca_cert_path = ca_cert_path == nil ? "" : ca_cert_path
      @client_cert_path = client_cert_path == nil ? "" : client_cert_path
      @client_key_path = client_key_path == nil ? "" : client_key_path
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @pki_mount_point = pki_mount_point == nil ? "" : pki_mount_point
      @server_address = server_address == nil ? "" : server_address
      @signing_role = signing_role == nil ? "" : signing_role
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTLSStore
    # A path to a CA file accessible by a Node
    attr_accessor :ca_cert_path
    # A path to a client certificate file accessible by a Node
    attr_accessor :client_cert_path
    # A path to a client key file accessible by a Node
    attr_accessor :client_key_path
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_cert_path: nil,
      client_cert_path: nil,
      client_key_path: nil,
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @ca_cert_path = ca_cert_path == nil ? "" : ca_cert_path
      @client_cert_path = client_cert_path == nil ? "" : client_cert_path
      @client_key_path = client_key_path == nil ? "" : client_key_path
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTokenCertSSHStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA in minutes. Recommended value is 5.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # The signing role to be used for signing certificates
    attr_accessor :signing_role
    # The mount point of the SSH engine configured with the desired CA
    attr_accessor :ssh_mount_point
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      signing_role: nil,
      ssh_mount_point: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @signing_role = signing_role == nil ? "" : signing_role
      @ssh_mount_point = ssh_mount_point == nil ? "" : ssh_mount_point
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTokenCertX509Store
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # The lifetime of certificates issued by this CA represented in minutes.
    attr_accessor :issuedcertttlminutes
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The mount point of the PKI engine configured with the desired CA
    attr_accessor :pki_mount_point
    # The URL of the Vault to target
    attr_accessor :server_address
    # The signing role to be used for signing certificates
    attr_accessor :signing_role
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      issuedcertttlminutes: nil,
      name: nil,
      namespace: nil,
      pki_mount_point: nil,
      server_address: nil,
      signing_role: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @issuedcertttlminutes = issuedcertttlminutes == nil ? 0 : issuedcertttlminutes
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @pki_mount_point = pki_mount_point == nil ? "" : pki_mount_point
      @server_address = server_address == nil ? "" : server_address
      @signing_role = signing_role == nil ? "" : signing_role
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTokenStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Workflows are the collection of rules that define the resources to which access can be requested,
  # the users that can request that access, and the mechanism for approving those requests which can either
  # but automatic approval or a set of users authorized to approve the requests.
  class Workflow
    # AccessRules is a list of access rules defining the resources this Workflow provides access to.
    attr_accessor :access_rules
    # Optional approval flow ID identifies an approval flow that linked to the workflow
    attr_accessor :approval_flow_id
    # Optional auto grant setting to automatically approve requests or not, defaults to false.
    attr_accessor :auto_grant
    # Optional description of the Workflow.
    attr_accessor :description
    # Optional enabled state for workflow. This setting may be overridden by the system if
    # the workflow doesn't meet the requirements to be enabled or if other conditions prevent
    # enabling the workflow. The requirements to enable a workflow are that the workflow must be
    # either set up for with auto grant enabled or have one or more WorkflowApprovers created for
    # the workflow.
    attr_accessor :enabled
    # Unique identifier of the Workflow.
    attr_accessor :id
    # Unique human-readable name of the Workflow.
    attr_accessor :name
    # Optional weight for workflow to specify it's priority in matching a request.
    attr_accessor :weight

    def initialize(
      access_rules: nil,
      approval_flow_id: nil,
      auto_grant: nil,
      description: nil,
      enabled: nil,
      id: nil,
      name: nil,
      weight: nil
    )
      @access_rules = access_rules == nil ? SDM::_porcelain_zero_value_access_rules() : access_rules
      @approval_flow_id = approval_flow_id == nil ? "" : approval_flow_id
      @auto_grant = auto_grant == nil ? false : auto_grant
      @description = description == nil ? "" : description
      @enabled = enabled == nil ? false : enabled
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @weight = weight == nil ? 0 : weight
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApprover is an account or a role with the ability to approve requests bound to a workflow.
  class WorkflowApprover
    # The approver account id.
    attr_accessor :account_id
    # Unique identifier of the WorkflowApprover.
    attr_accessor :id
    # The approver role id
    attr_accessor :role_id
    # The workflow id.
    attr_accessor :workflow_id

    def initialize(
      account_id: nil,
      id: nil,
      role_id: nil,
      workflow_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproverGetResponse returns a requested WorkflowApprover.
  class WorkflowApproverGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested WorkflowApprover.
    attr_accessor :workflow_approver

    def initialize(
      meta: nil,
      rate_limit: nil,
      workflow_approver: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow_approver = workflow_approver == nil ? nil : workflow_approver
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproverHistory provides records of all changes to the state of a WorkflowApprover.
  class WorkflowApproverHistory
    # The unique identifier of the Activity that produced this change to the WorkflowApprover.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this WorkflowApprover was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the WorkflowApprover state was recorded.
    attr_accessor :timestamp
    # The complete WorkflowApprover state at this time.
    attr_accessor :workflow_approver

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow_approver: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow_approver = workflow_approver == nil ? nil : workflow_approver
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproversCreateRequest specifies the workflowID and approverID of a new
  # workflow approver to be created.
  class WorkflowApproversCreateRequest
    # Parameters to define the new WorkflowApprover.
    attr_accessor :workflow_approver

    def initialize(
      workflow_approver: nil
    )
      @workflow_approver = workflow_approver == nil ? nil : workflow_approver
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproversCreateResponse reports how the WorkflowApprover was created in the system.
  class WorkflowApproversCreateResponse
    # Rate limit information.
    attr_accessor :rate_limit
    # The created workflow approver.
    attr_accessor :workflow_approver

    def initialize(
      rate_limit: nil,
      workflow_approver: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow_approver = workflow_approver == nil ? nil : workflow_approver
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproversDeleteRequest specifies the ID of a WorkflowApprover to be deleted.
  class WorkflowApproversDeleteRequest
    # The unique identifier of the WorkflowApprover to delete.
    attr_accessor :id

    def initialize(
      id: nil
    )
      @id = id == nil ? "" : id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproversDeleteResponse reports how the WorkflowApprover was deleted in the system.
  class WorkflowApproversDeleteResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproversListRequest specifies criteria for retrieving a list of
  # WorkflowApprover records
  class WorkflowApproversListRequest
    # A human-readable filter query string.
    attr_accessor :filter

    def initialize(
      filter: nil
    )
      @filter = filter == nil ? "" : filter
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproversListResponse returns a list of WorkflowApprover records that meet
  # the criteria of a WorkflowApproversListRequest.
  class WorkflowApproversListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowAssignment links a Resource to a Workflow. The assigned resources are those that a user can request
  # access to via the workflow.
  class WorkflowAssignment
    # The resource id.
    attr_accessor :resource_id
    # The workflow id.
    attr_accessor :workflow_id

    def initialize(
      resource_id: nil,
      workflow_id: nil
    )
      @resource_id = resource_id == nil ? "" : resource_id
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowAssignmentsHistory provides records of all changes to the state of a WorkflowAssignment.
  class WorkflowAssignmentHistory
    # The unique identifier of the Activity that produced this change to the WorkflowAssignment.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this WorkflowAssignment was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the WorkflowAssignment state was recorded.
    attr_accessor :timestamp
    # The complete WorkflowAssignment state at this time.
    attr_accessor :workflow_assignment

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow_assignment: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow_assignment = workflow_assignment == nil ? nil : workflow_assignment
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowAssignmentsListRequest specifies criteria for retrieving a list of
  # WorkflowAssignment records
  class WorkflowAssignmentsListRequest
    # A human-readable filter query string.
    attr_accessor :filter

    def initialize(
      filter: nil
    )
      @filter = filter == nil ? "" : filter
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowAssignmentsListResponse returns a list of WorkflowAssignment records that meet
  # the criteria of a WorkflowAssignmentsListRequest.
  class WorkflowAssignmentsListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowCreateResponse reports how the Workflow was created in the system.
  class WorkflowCreateResponse
    # Rate limit information.
    attr_accessor :rate_limit
    # The created workflow.
    attr_accessor :workflow

    def initialize(
      rate_limit: nil,
      workflow: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow = workflow == nil ? nil : workflow
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowDeleteResponse returns information about a Workflow that was deleted.
  class WorkflowDeleteResponse
    # The deleted workflow id.
    attr_accessor :id
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      id: nil,
      rate_limit: nil
    )
      @id = id == nil ? "" : id
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowGetResponse returns a requested Workflow.
  class WorkflowGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Workflow.
    attr_accessor :workflow

    def initialize(
      meta: nil,
      rate_limit: nil,
      workflow: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow = workflow == nil ? nil : workflow
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowsHistory provides records of all changes to the state of a Workflow.
  class WorkflowHistory
    # The unique identifier of the Activity that produced this change to the Workflow.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Workflow state was recorded.
    attr_accessor :timestamp
    # The complete Workflow state at this time.
    attr_accessor :workflow

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow = workflow == nil ? nil : workflow
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowListResponse returns a list of Workflow records that meet
  # the criteria of a WorkflowListRequest.
  class WorkflowListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRole links a role to a workflow. The linked roles indicate which roles a user must be a part of
  # to request access to a resource via the workflow.
  class WorkflowRole
    # Unique identifier of the WorkflowRole.
    attr_accessor :id
    # The role id.
    attr_accessor :role_id
    # The workflow id.
    attr_accessor :workflow_id

    def initialize(
      id: nil,
      role_id: nil,
      workflow_id: nil
    )
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRoleGetResponse returns a requested WorkflowRole.
  class WorkflowRoleGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested WorkflowRole.
    attr_accessor :workflow_role

    def initialize(
      meta: nil,
      rate_limit: nil,
      workflow_role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow_role = workflow_role == nil ? nil : workflow_role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesHistory provides records of all changes to the state of a WorkflowRole
  class WorkflowRoleHistory
    # The unique identifier of the Activity that produced this change to the WorkflowRole.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this WorkflowRole was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the WorkflowRole state was recorded.
    attr_accessor :timestamp
    # The complete WorkflowRole state at this time.
    attr_accessor :workflow_role

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow_role: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow_role = workflow_role == nil ? nil : workflow_role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesCreateRequest specifies the workflowID and roleID of a new
  # workflow role to be created.
  class WorkflowRolesCreateRequest
    # Parameters to define the new WorkflowRole.
    attr_accessor :workflow_role

    def initialize(
      workflow_role: nil
    )
      @workflow_role = workflow_role == nil ? nil : workflow_role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesCreateResponse reports how the WorkflowRole was created in the system.
  class WorkflowRolesCreateResponse
    # Rate limit information.
    attr_accessor :rate_limit
    # The created workflow role.
    attr_accessor :workflow_role

    def initialize(
      rate_limit: nil,
      workflow_role: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow_role = workflow_role == nil ? nil : workflow_role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesDeleteRequest specifies the ID of a WorkflowRole to be deleted.
  class WorkflowRolesDeleteRequest
    # The unique identifier of the WorkflowRole to delete.
    attr_accessor :id

    def initialize(
      id: nil
    )
      @id = id == nil ? "" : id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesDeleteResponse reports how the WorkflowRole was deleted in the system.
  class WorkflowRolesDeleteResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesListRequest specifies criteria for retrieving a list of
  # WorkflowRole records
  class WorkflowRolesListRequest
    # A human-readable filter query string.
    attr_accessor :filter

    def initialize(
      filter: nil
    )
      @filter = filter == nil ? "" : filter
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesListResponse returns a list of WorkflowRole records that meet
  # the criteria of a WorkflowRolesListRequest.
  class WorkflowRolesListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowUpdateResponse returns the fields of a Workflow after it has been updated by
  # a WorkflowUpdateRequest.
  class WorkflowUpdateResponse
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated workflow.
    attr_accessor :workflow

    def initialize(
      rate_limit: nil,
      workflow: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @workflow = workflow == nil ? nil : workflow
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # @private
  def self._porcelain_zero_value_tags()
    {}
  end
  # @private
  def self._porcelain_zero_value_access_rules()
    []
  end
end
