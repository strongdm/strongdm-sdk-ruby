# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal Code generated by protogen. DO NOT EDIT.

module SDM
  class AKS
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSBasicAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccount
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSServiceAccountUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AKSUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWS
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The AWS region healthcheck requests should attempt to connect to.
    attr_accessor :healthcheck_region
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_region: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_region = healthcheck_region == nil ? "" : healthcheck_region
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AWSConsole is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class AWSConsole
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
    attr_accessor :enable_env_variables
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to.
    attr_accessor :region
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The length of time in seconds AWS console sessions will live before needing to reauthenticate.
    attr_accessor :session_expiry
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      enable_env_variables: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      session_expiry: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @enable_env_variables = enable_env_variables == nil ? false : enable_env_variables
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @session_expiry = session_expiry == nil ? 0 : session_expiry
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AWSConsoleStaticKeyPair is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class AWSConsoleStaticKeyPair
    # The Access Key ID to authenticate with.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to.
    attr_accessor :region
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to authenticate with.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The length of time in seconds AWS console sessions will live before needing to reauthenticate.
    attr_accessor :session_expiry
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      session_expiry: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @session_expiry = session_expiry == nil ? 0 : session_expiry
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AWSStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The AWS region to target e.g. us-east-1
    attr_accessor :region
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      region: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @region = region == nil ? "" : region
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequests are requests for access to a resource that may match a Workflow.
  class AccessRequest
    # The account that initiated the request.
    attr_accessor :account_id
    # The account grant created, if it exists.
    attr_accessor :grant_id
    # The access request id.
    attr_accessor :id
    # The reason the access was requested.
    attr_accessor :reason
    # The resource id.
    attr_accessor :resource_id
    # The timestamp when the requested access will be granted.
    # If this field is not specified it will default to the current time.
    attr_accessor :start_from
    # The status of the access request.
    attr_accessor :status
    # The timestamp when the status changed.
    attr_accessor :status_at
    # The timestamp when the requested access will expire.
    attr_accessor :valid_until
    # The workflow the request bound to.
    attr_accessor :workflow_id

    def initialize(
      account_id: nil,
      grant_id: nil,
      id: nil,
      reason: nil,
      resource_id: nil,
      start_from: nil,
      status: nil,
      status_at: nil,
      valid_until: nil,
      workflow_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @grant_id = grant_id == nil ? "" : grant_id
      @id = id == nil ? "" : id
      @reason = reason == nil ? "" : reason
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
      @status = status == nil ? "" : status
      @status_at = status_at == nil ? nil : status_at
      @valid_until = valid_until == nil ? nil : valid_until
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestEvents hold information about events related to an access
  # request such as creation, approval and denial.
  class AccessRequestEvent
    # The account responsible for the event.
    attr_accessor :actor_id
    # The access request event id.
    attr_accessor :id
    # The metadata about the event
    attr_accessor :metadata
    # The request that the event is bound to.
    attr_accessor :request_id
    # The type of event.
    attr_accessor :type

    def initialize(
      actor_id: nil,
      id: nil,
      metadata: nil,
      request_id: nil,
      type: nil
    )
      @actor_id = actor_id == nil ? "" : actor_id
      @id = id == nil ? "" : id
      @metadata = metadata == nil ? "" : metadata
      @request_id = request_id == nil ? "" : request_id
      @type = type == nil ? "" : type
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestEventHistory records the state of a AccessRequest at a given point in time,
  # where every change (create, update and delete) to a AccessRequest produces an
  # AccessRequestEventHistory record.
  class AccessRequestEventHistory
    # The complete AccessRequestEvent state at this time.
    attr_accessor :access_request_event
    # The unique identifier of the Activity that produced this change to the AccessRequest.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccessRequest state was recorded.
    attr_accessor :timestamp

    def initialize(
      access_request_event: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @access_request_event = access_request_event == nil ? nil : access_request_event
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestHistory records the state of a AccessRequest at a given point in time,
  # where every change (create, update and delete) to a AccessRequest produces an
  # AccessRequestHistory record.
  class AccessRequestHistory
    # The complete AccessRequest state at this time.
    attr_accessor :access_request
    # The unique identifier of the Activity that produced this change to the AccessRequest.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccessRequest state was recorded.
    attr_accessor :timestamp

    def initialize(
      access_request: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @access_request = access_request == nil ? nil : access_request
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestListRequest specifies criteria for retrieving a list of
  # AccessRequest records
  class AccessRequestListRequest
    # A human-readable filter query string.
    attr_accessor :filter

    def initialize(
      filter: nil
    )
      @filter = filter == nil ? "" : filter
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccessRequestListResponse reports how the Workflow was created in the system.
  class AccessRequestListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachments assign an account to a role.
  class AccountAttachment
    # The id of the account of this AccountAttachment.
    attr_accessor :account_id
    # Unique identifier of the AccountAttachment.
    attr_accessor :id
    # The id of the attached role of this AccountAttachment.
    attr_accessor :role_id

    def initialize(
      account_id: nil,
      id: nil,
      role_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentCreateResponse reports how the AccountAttachments were created in the system.
  class AccountAttachmentCreateResponse
    # The created AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentDeleteResponse returns information about a AccountAttachment that was deleted.
  class AccountAttachmentDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentGetResponse returns a requested AccountAttachment.
  class AccountAttachmentGetResponse
    # The requested AccountAttachment.
    attr_accessor :account_attachment
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_attachment: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountAttachmentHistory records the state of an AccountAttachment at a given point in time,
  # where every change (create or delete) to an AccountAttachment produces an
  # AccountAttachmentHistory record.
  class AccountAttachmentHistory
    # The complete AccountAttachment state at this time.
    attr_accessor :account_attachment
    # The unique identifier of the Activity that produced this change to the AccountAttachment.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountAttachment was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountAttachment state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_attachment: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_attachment = account_attachment == nil ? nil : account_attachment
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountCreateResponse reports how the Accounts were created in the system.
  class AccountCreateResponse
    # The created Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Account. The Account will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil,
      token: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountDeleteResponse returns information about a Account that was deleted.
  class AccountDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGetResponse returns a requested Account.
  class AccountGetResponse
    # The requested Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrants connect a resource directly to an account, giving the account the permission to connect to that resource.
  class AccountGrant
    # The account ID of this AccountGrant.
    attr_accessor :account_id
    # Unique identifier of the AccountGrant.
    attr_accessor :id
    # The resource ID of this AccountGrant.
    attr_accessor :resource_id
    # The timestamp when the resource will be granted. When creating an AccountGrant, if this field is not specified, it will default to the current time.
    attr_accessor :start_from
    # The timestamp when the resource grant will expire.
    attr_accessor :valid_until

    def initialize(
      account_id: nil,
      id: nil,
      resource_id: nil,
      start_from: nil,
      valid_until: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
      @start_from = start_from == nil ? nil : start_from
      @valid_until = valid_until == nil ? nil : valid_until
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantCreateResponse reports how the AccountGrants were created in the system.
  class AccountGrantCreateResponse
    # The created AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantDeleteResponse returns information about a AccountGrant that was deleted.
  class AccountGrantDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantGetResponse returns a requested AccountGrant.
  class AccountGrantGetResponse
    # The requested AccountGrant.
    attr_accessor :account_grant
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account_grant: nil,
      meta: nil,
      rate_limit: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountGrantHistory records the state of an AccountGrant at a given point in time,
  # where every change (create or delete) to an AccountGrant produces an
  # AccountGrantHistory record.
  class AccountGrantHistory
    # The complete AccountGrant state at this time.
    attr_accessor :account_grant
    # The unique identifier of the Activity that produced this change to the AccountGrant.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountGrant was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountGrant state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_grant: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_grant = account_grant == nil ? nil : account_grant
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountHistory records the state of an Account at a given point in time,
  # where every change (create, update and delete) to an Account produces an
  # AccountHistory record.
  class AccountHistory
    # The complete Account state at this time.
    attr_accessor :account
    # The unique identifier of the Activity that produced this change to the Account.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Account was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Account state was recorded.
    attr_accessor :timestamp

    def initialize(
      account: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account = account == nil ? nil : account
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountPermission represents an individual API action available to an account.
  class AccountPermission
    # The unique identifier of the Account this permission belongs to.
    attr_accessor :account_id
    # The most recent time at which the permission was granted. If a permission was
    # granted, revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The value of this permission, split into vertical and action e.g.
    # 'secretstore:List', 'role:update'
    attr_accessor :permission
    # The scope of this permission. A global scope means this action can be taken
    # on any entity; otherwise the action can only be taken on or in the scope of
    # the scoped id.
    attr_accessor :scope
    # The ID to which or in whose context this operation is permitted. e.g. The ID of a
    # role that a team leader has the abillity to remove and add accounts to, or the
    # ID of a resource that a user has the permission to connect to. If Scope is global,
    # scoped id is not populated.
    attr_accessor :scoped_id

    def initialize(
      account_id: nil,
      granted_at: nil,
      permission: nil,
      scope: nil,
      scoped_id: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @granted_at = granted_at == nil ? nil : granted_at
      @permission = permission == nil ? "" : permission
      @scope = scope == nil ? "" : scope
      @scoped_id = scoped_id == nil ? "" : scoped_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountResource represents an individual access grant of a Account to a Resource.
  class AccountResource
    # The unique identifier of the AccountGrant through which the Account was granted access to the Resource.
    # If empty, access was not granted through an AccountGrant.
    attr_accessor :account_grant_id
    # The unique identifier of the Account to which access is granted.
    attr_accessor :account_id
    # The time this grant was created, distinct from 'granted at' in the case where access is scheduled
    # for the future. If access was granted, revoked, and granted again, this will reflect the later creation time.
    attr_accessor :created_at
    # The time at which access will expire. If empty, this access has no expiration.
    attr_accessor :expires_at
    # The most recent time at which access was granted. If access was granted,
    # revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The unique identifier of the Resource to which access is granted.
    attr_accessor :resource_id
    # The unique identifier of the Role through which the Account was granted access to the Resource.
    # If empty, access was not granted through an AccountAttachment to a Role.
    attr_accessor :role_id

    def initialize(
      account_grant_id: nil,
      account_id: nil,
      created_at: nil,
      expires_at: nil,
      granted_at: nil,
      resource_id: nil,
      role_id: nil
    )
      @account_grant_id = account_grant_id == nil ? "" : account_grant_id
      @account_id = account_id == nil ? "" : account_id
      @created_at = created_at == nil ? nil : created_at
      @expires_at = expires_at == nil ? nil : expires_at
      @granted_at = granted_at == nil ? nil : granted_at
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountResourceHistory records the state of a AccountResource at a given point in time,
  # where every change (create or delete) to a AccountResource produces an
  # AccountResourceHistory record.
  class AccountResourceHistory
    # The complete AccountResource state at this time.
    attr_accessor :account_resource
    # The unique identifier of the Activity that produced this change to the AccountResource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this AccountResource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the AccountResource state was recorded.
    attr_accessor :timestamp

    def initialize(
      account_resource: nil,
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil
    )
      @account_resource = account_resource == nil ? nil : account_resource
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AccountUpdateResponse returns the fields of a Account after it has been updated by
  # a AccountUpdateRequest.
  class AccountUpdateResponse
    # The updated Account.
    attr_accessor :account
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      account: nil,
      meta: nil,
      rate_limit: nil
    )
      @account = account == nil ? nil : account
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # An Activity is a record of an action taken against a strongDM deployment, e.g.
  # a user creation, resource deletion, sso configuration change, etc.
  class Activity
    # The account who executed this activity. If the actor later has a name or email change,
    # that change is not reflected here. Actor is a snapshot of the executing account at
    # the time an activity took place.
    attr_accessor :actor
    # The time this activity took effect.
    attr_accessor :completed_at
    # A humanized description of the activity.
    attr_accessor :description
    # The entities involved in this activity. These entities can be any first class
    # entity in the strongDM system, eg. a user, a role, a node, an account grant. Not
    # every activity affects explicit entities.
    attr_accessor :entities
    # Unique identifier of the Activity.
    attr_accessor :id
    # The IP from which this action was taken.
    attr_accessor :ip_address
    # The User Agent present when this request was executed. Generally a client type and version
    # like strongdm-cli/55.66.77
    attr_accessor :user_agent
    # The kind of activity which has taken place.
    attr_accessor :verb

    def initialize(
      actor: nil,
      completed_at: nil,
      description: nil,
      entities: nil,
      id: nil,
      ip_address: nil,
      user_agent: nil,
      verb: nil
    )
      @actor = actor == nil ? nil : actor
      @completed_at = completed_at == nil ? nil : completed_at
      @description = description == nil ? "" : description
      @entities = entities == nil ? [] : entities
      @id = id == nil ? "" : id
      @ip_address = ip_address == nil ? "" : ip_address
      @user_agent = user_agent == nil ? "" : user_agent
      @verb = verb == nil ? "" : verb
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActivityActor
    # The external ID of the actor at the time this activity occurred.
    attr_accessor :activity_external_id
    # The email of the actor at the time this activity occurred.
    attr_accessor :email
    # The first name of the actor at the time this activity occurred.
    attr_accessor :first_name
    # Unique identifier of the actor. Immutable.
    attr_accessor :id
    # The last name of the actor at the time this activity occurred.
    attr_accessor :last_name

    def initialize(
      activity_external_id: nil,
      email: nil,
      first_name: nil,
      id: nil,
      last_name: nil
    )
      @activity_external_id = activity_external_id == nil ? "" : activity_external_id
      @email = email == nil ? "" : email
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ActivityEntity
    # The email of the affected entity, if it has one (for example, if it is an account).
    attr_accessor :email
    # The external ID of the affected entity, if it has one (for example, if it is an account).
    attr_accessor :external_id
    # The unique identifier of the entity this activity affected.
    attr_accessor :id
    # A display name representing the affected entity.
    attr_accessor :name
    # The type of entity affected, one of the Activity Entities constants.
    attr_accessor :type

    def initialize(
      email: nil,
      external_id: nil,
      id: nil,
      name: nil,
      type: nil
    )
      @email = email == nil ? "" : email
      @external_id = external_id == nil ? "" : external_id
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @type = type == nil ? "" : type
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ActivityGetResponse returns a requested Activity.
  class ActivityGetResponse
    # The requested Activity.
    attr_accessor :activity
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      activity: nil,
      meta: nil,
      rate_limit: nil
    )
      @activity = activity == nil ? nil : activity
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKS
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSInstanceProfile
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSInstanceProfileUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonEKSUserImpersonation
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The name of the cluster to connect to.
    attr_accessor :cluster_name
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      certificate_authority: nil,
      cluster_name: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @cluster_name = cluster_name == nil ? "" : cluster_name
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonES
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial e.g. search-?.region.es.amazonaws.com"
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AmazonMQAMQP091
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Athena
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The AWS S3 output location.
    attr_accessor :output
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to e.g. us-east-1.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      output: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @output = output == nil ? "" : output
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraMysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AuroraPostgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Azure
    # The application ID to authenticate with.
    attr_accessor :app_id
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The tenant ID to authenticate to.
    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureCertificate
    # The application ID to authenticate with.
    attr_accessor :app_id
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The service Principal certificate file, both private and public key included.
    attr_accessor :client_certificate
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The tenant ID to authenticate to.
    attr_accessor :tenant_id

    def initialize(
      app_id: nil,
      bind_interface: nil,
      client_certificate: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @app_id = app_id == nil ? "" : app_id
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureMysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzurePostgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with. For Azure Postgres, this also will include the hostname of the target server for Azure Single Server compatibility. For Flexible servers, use the normal Postgres type.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # AzurePostgresManagedIdentity is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class AzurePostgresManagedIdentity
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class AzureStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The URI of the key vault to target e.g. https://myvault.vault.azure.net
    attr_accessor :vault_uri

    def initialize(
      id: nil,
      name: nil,
      tags: nil,
      vault_uri: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @vault_uri = vault_uri == nil ? "" : vault_uri
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class BigQuery
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The JSON Private key to authenticate with.
    attr_accessor :private_key
    # The project to connect to.
    attr_accessor :project
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      private_key: nil,
      project: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @project = project == nil ? "" : project
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cassandra
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Citus
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Clustrix
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Cockroach
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelGetSSHCAPublicKeyResponse represents a request for an
  # organization's SSH Certificate Authority public key.
  class ControlPanelGetSSHCAPublicKeyResponse
    # Reserved for future use.
    attr_accessor :meta
    # The public key of the SSH Certificate Authority, in OpenSSH RSA public
    # key format.
    attr_accessor :public_key
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      public_key: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @public_key = public_key == nil ? "" : public_key
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ControlPanelVerifyJWTResponse reports whether x-sdm-token is valid.
  class ControlPanelVerifyJWTResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # Reports if the given token is valid.
    attr_accessor :valid

    def initialize(
      meta: nil,
      rate_limit: nil,
      valid: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @valid = valid == nil ? false : valid
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CreateResponseMetadata is reserved for future use.
  class CreateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CyberarkConjurStore
    # The URL of the Cyberark instance
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # CyberarkPAMExperimentalStore is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class CyberarkPAMExperimentalStore
    # The URL of the Cyberark instance
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class CyberarkPAMStore
    # The URL of the Cyberark instance
    attr_accessor :appurl
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      appurl: nil,
      id: nil,
      name: nil,
      tags: nil
    )
      @appurl = appurl == nil ? "" : appurl
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2I
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DB2LUW
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # DeleteResponseMetadata is reserved for future use.
  class DeleteResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DelineaStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The URL of the Delinea instance
    attr_accessor :server_url
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The tenant name to target
    attr_accessor :tenant_name

    def initialize(
      id: nil,
      name: nil,
      server_url: nil,
      tags: nil,
      tenant_name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @server_url = server_url == nil ? "" : server_url
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_name = tenant_name == nil ? "" : tenant_name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBHost
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DocumentDBReplicaSet
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Set to connect to a replica instead of the primary node.
    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Druid
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class DynamoDB
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial e.g. dynamodb.region.amazonaws.com
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The region to authenticate requests against e.g. us-east-1
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Elastic
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class ElasticacheRedis
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCP
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # The service account keyfile to authenticate with.
    attr_accessor :keyfile
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Space separated scopes that this login should assume into when authenticating.
    attr_accessor :scopes
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      id: nil,
      keyfile: nil,
      name: nil,
      port_override: nil,
      scopes: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @keyfile = keyfile == nil ? "" : keyfile
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @scopes = scopes == nil ? "" : scopes
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GCPStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The GCP project ID to target.
    attr_accessor :projectid
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      projectid: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @projectid = projectid == nil ? "" : projectid
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Gateway represents a StrongDM CLI installation running in gateway mode.
  class Gateway
    # The hostname/port tuple which the gateway daemon will bind to.
    # If not provided on create, set to "0.0.0.0:listen_address_port".
    attr_accessor :bind_address
    # Device is a read only device name uploaded by the gateway process when
    # it comes online.
    attr_accessor :device
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways. Deprecated.
    attr_accessor :gateway_filter
    # Unique identifier of the Gateway.
    attr_accessor :id
    # The public hostname/port tuple at which the gateway will be accessible to clients.
    attr_accessor :listen_address
    # Location is a read only network location uploaded by the gateway process
    # when it comes online.
    attr_accessor :location
    # Maintenance Windows define when this node is allowed to restart. If a node
    # is requested to restart, it will check each window to determine if any of
    # them permit it to restart, and if any do, it will. This check is repeated
    # per window until the restart is successfully completed.
    #
    # If not set here, may be set on the command line or via an environment variable
    # on the process itself; any server setting will take precedence over local
    # settings. This setting is ineffective for nodes below version 38.44.0.
    #
    # If this setting is not applied via this remote configuration or via local
    # configuration, the default setting is used: always allow restarts if serving
    # no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
    attr_accessor :maintenance_windows
    # Unique human-readable name of the Gateway. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the gateway. One of: "new", "verifying_restart",
    # "restarting", "started", "stopped", "dead", "unknown"
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # Version is a read only sdm binary version uploaded by the gateway process
    # when it comes online.
    attr_accessor :version

    def initialize(
      bind_address: nil,
      device: nil,
      gateway_filter: nil,
      id: nil,
      listen_address: nil,
      location: nil,
      maintenance_windows: nil,
      name: nil,
      state: nil,
      tags: nil,
      version: nil
    )
      @bind_address = bind_address == nil ? "" : bind_address
      @device = device == nil ? "" : device
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @listen_address = listen_address == nil ? "" : listen_address
      @location = location == nil ? "" : location
      @maintenance_windows = maintenance_windows == nil ? [] : maintenance_windows
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @version = version == nil ? "" : version
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # GetResponseMetadata is reserved for future use.
  class GetResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKE
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The service account key to authenticate with.
    attr_accessor :service_account_key
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      service_account_key: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class GoogleGKEUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The endpoint to dial.
    attr_accessor :endpoint
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The service account key to authenticate with.
    attr_accessor :service_account_key
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      egress_filter: nil,
      endpoint: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      secret_store_id: nil,
      service_account_key: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @service_account_key = service_account_key == nil ? "" : service_account_key
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Greenplum
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPAuth
    # The content to set as the authorization header.
    attr_accessor :auth_header
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Automatically redirect to this path upon connecting.
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # Header names (e.g. Authorization), to omit from logs.
    attr_accessor :headers_blacklist
    # This path will be used to check the health of your site.
    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host header will be overwritten with this field if provided.
    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url

    def initialize(
      auth_header: nil,
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @auth_header = auth_header == nil ? "" : auth_header
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPBasicAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Automatically redirect to this path upon connecting.
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # Header names (e.g. Authorization), to omit from logs.
    attr_accessor :headers_blacklist
    # This path will be used to check the health of your site.
    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host header will be overwritten with this field if provided.
    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      password: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class HTTPNoAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Automatically redirect to this path upon connecting.
    attr_accessor :default_path
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # Header names (e.g. Authorization), to omit from logs.
    attr_accessor :headers_blacklist
    # This path will be used to check the health of your site.
    attr_accessor :healthcheck_path
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host header will be overwritten with this field if provided.
    attr_accessor :host_override
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The base address of your website without the path.
    attr_accessor :url

    def initialize(
      bind_interface: nil,
      default_path: nil,
      egress_filter: nil,
      headers_blacklist: nil,
      healthcheck_path: nil,
      healthy: nil,
      host_override: nil,
      id: nil,
      name: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      url: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @default_path = default_path == nil ? "" : default_path
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @headers_blacklist = headers_blacklist == nil ? "" : headers_blacklist
      @healthcheck_path = healthcheck_path == nil ? "" : healthcheck_path
      @healthy = healthy == nil ? false : healthy
      @host_override = host_override == nil ? "" : host_override
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @url = url == nil ? "" : url
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Kubernetes
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesBasicAuth
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccount
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesServiceAccountUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The API token to authenticate with.
    attr_accessor :token

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      token: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class KubernetesUserImpersonation
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The path used to check the health of your connection.  Defaults to `default`.
    attr_accessor :healthcheck_namespace
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      egress_filter: nil,
      healthcheck_namespace: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_namespace = healthcheck_namespace == nil ? "" : healthcheck_namespace
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MTLSMysql is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MTLSMysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Server name for TLS verification (unverified by StrongDM if empty)
    attr_accessor :server_name
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      server_name: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MTLSPostgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The CA to authenticate TLS connections with.
    attr_accessor :certificate_authority
    # The certificate to authenticate TLS connections with.
    attr_accessor :client_certificate
    # The key to authenticate TLS connections with.
    attr_accessor :client_key
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Server name for TLS verification (unverified by StrongDM if empty)
    attr_accessor :server_name
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      certificate_authority: nil,
      client_certificate: nil,
      client_key: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      server_name: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @certificate_authority = certificate_authority == nil ? "" : certificate_authority
      @client_certificate = client_certificate == nil ? "" : client_certificate
      @client_key = client_key == nil ? "" : client_key
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_name = server_name == nil ? "" : server_name
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Maria
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memcached
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Memsql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoHost is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoHost
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoLegacyHost
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class MongoLegacyReplicaset
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Set to connect to a replica instead of the primary node.
    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoReplicaSet is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoReplicaSet
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # Set to connect to a replica instead of the primary node.
    attr_accessor :connect_to_replica
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The name of the mongo replicaset.
    attr_accessor :replica_set
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      connect_to_replica: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      replica_set: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @connect_to_replica = connect_to_replica == nil ? false : connect_to_replica
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @replica_set = replica_set == nil ? "" : replica_set
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # MongoShardedCluster is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class MongoShardedCluster
    # The authentication database to use.
    attr_accessor :auth_database
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      auth_database: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @auth_database = auth_database == nil ? "" : auth_database
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Mysql
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Neptune
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class NeptuneIAM
    # The Access Key ID to use to authenticate.
    attr_accessor :access_key
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
    attr_accessor :endpoint
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The AWS region to connect to.
    attr_accessor :region
    # The role to assume after logging in.
    attr_accessor :role_arn
    # The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
    attr_accessor :role_external_id
    # The Secret Access Key to use to authenticate.
    attr_accessor :secret_access_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_key: nil,
      bind_interface: nil,
      egress_filter: nil,
      endpoint: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      region: nil,
      role_arn: nil,
      role_external_id: nil,
      secret_access_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @access_key = access_key == nil ? "" : access_key
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @endpoint = endpoint == nil ? "" : endpoint
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @region = region == nil ? "" : region
      @role_arn = role_arn == nil ? "" : role_arn
      @role_external_id = role_external_id == nil ? "" : role_external_id
      @secret_access_key = secret_access_key == nil ? "" : secret_access_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeCreateResponse reports how the Nodes were created in the system.
  class NodeCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit
    # The auth token generated for the Node. The Node will use this token to
    # authenticate with the strongDM API.
    attr_accessor :token

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil,
      token: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @token = token == nil ? "" : token
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeDeleteResponse returns information about a Node that was deleted.
  class NodeDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeGetResponse returns a requested Node.
  class NodeGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeHistory records the state of a Node at a given point in time,
  # where every change (create, update and delete) to a Node produces an
  # NodeHistory record.
  class NodeHistory
    # The unique identifier of the Activity that produced this change to the Node.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Node was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Node state at this time.
    attr_accessor :node
    # The time at which the Node state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      node: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @node = node == nil ? nil : node
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class NodeMaintenanceWindow
    # Cron job syntax for when this maintenance window is active. On this schedule, associated
    # nodes will restart if requested, provided other checks allow the restart to proceed. Times
    # are represented in UTC.
    # e.g. * 7 * * 0,6 to check for a restart at every minute from 7:00 to 8:00 UTC on Sunday and
    # Saturday. Not all possible inputs are supported: the month and day of month selections
    # must be '*'.
    attr_accessor :cron_schedule
    # Require Idleness defines whether this window can sever live connections. If true,
    # this window will not allow a node to be restarted unless it is serving no connections.
    # If false, given a restart of the node has been requested (for an update, usually), the
    # node will restart as soon as it enters an allowed day / hour combination. At least one
    # maintenance window, out of all configured windows for a node, must have this as false.
    attr_accessor :require_idleness

    def initialize(
      cron_schedule: nil,
      require_idleness: nil
    )
      @cron_schedule = cron_schedule == nil ? "" : cron_schedule
      @require_idleness = require_idleness == nil ? false : require_idleness
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # NodeUpdateResponse returns the fields of a Node after it has been updated by
  # a NodeUpdateRequest.
  class NodeUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The updated Node.
    attr_accessor :node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @node = node == nil ? nil : node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Oracle
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Organization
    # The Organization's authentication provider.
    attr_accessor :auth_provider
    # The time at which the Organization was created.
    attr_accessor :created_at
    # The Organization's idle timeout, if enabled.
    attr_accessor :idle_timeout
    # Indicates if the Organization has idle timeouts enabled.
    attr_accessor :idle_timeout_enabled
    # The Organization's type.
    attr_accessor :kind
    # The Organization's local log encryption encoder.
    attr_accessor :log_local_encoder
    # The Organization's local log format.
    attr_accessor :log_local_format
    # The Organization's local log storage.
    attr_accessor :log_local_storage
    # The Organization's remote log encryption encoder.
    attr_accessor :log_remote_encoder
    # The Organization's socket path for Socket local log storage.
    attr_accessor :log_socket_path
    # The Organization's TCP address for TCP or Syslog local log storage.
    attr_accessor :log_tcp_address
    # Indicates if the Organization has multi-factor authentication enabled.
    attr_accessor :mfa_enabled
    # The Organization's multi-factor authentication provider, if enabled.
    attr_accessor :mfa_provider
    # The Organization's name.
    attr_accessor :name
    # Indicates if the Organization requires secret stores.
    attr_accessor :require_secret_store
    # The Organization's URL for SAML metadata.
    attr_accessor :saml_metadata_url
    # The Organization's SCIM provider.
    attr_accessor :scim_provider
    # The Organization's label for sensitive resources.
    attr_accessor :sensitive_label
    # The Organization's session timeout, if enabled.
    attr_accessor :session_timeout
    # Indicates if the Organization has session timeouts enabled.
    attr_accessor :session_timeout_enabled
    # The Organization's SSH certificate authority public key.
    attr_accessor :ssh_certificate_authority_public_key
    # The time at which the Organization's SSH certificate authority was last updated.
    attr_accessor :ssh_certificate_authority_updated_at
    # The time at which the Organization was last updated.
    attr_accessor :updated_at
    # The Organization's web site domain.
    attr_accessor :websites_subdomain

    def initialize(
      auth_provider: nil,
      created_at: nil,
      idle_timeout: nil,
      idle_timeout_enabled: nil,
      kind: nil,
      log_local_encoder: nil,
      log_local_format: nil,
      log_local_storage: nil,
      log_remote_encoder: nil,
      log_socket_path: nil,
      log_tcp_address: nil,
      mfa_enabled: nil,
      mfa_provider: nil,
      name: nil,
      require_secret_store: nil,
      saml_metadata_url: nil,
      scim_provider: nil,
      sensitive_label: nil,
      session_timeout: nil,
      session_timeout_enabled: nil,
      ssh_certificate_authority_public_key: nil,
      ssh_certificate_authority_updated_at: nil,
      updated_at: nil,
      websites_subdomain: nil
    )
      @auth_provider = auth_provider == nil ? "" : auth_provider
      @created_at = created_at == nil ? nil : created_at
      @idle_timeout = idle_timeout == nil ? nil : idle_timeout
      @idle_timeout_enabled = idle_timeout_enabled == nil ? false : idle_timeout_enabled
      @kind = kind == nil ? "" : kind
      @log_local_encoder = log_local_encoder == nil ? "" : log_local_encoder
      @log_local_format = log_local_format == nil ? "" : log_local_format
      @log_local_storage = log_local_storage == nil ? "" : log_local_storage
      @log_remote_encoder = log_remote_encoder == nil ? "" : log_remote_encoder
      @log_socket_path = log_socket_path == nil ? "" : log_socket_path
      @log_tcp_address = log_tcp_address == nil ? "" : log_tcp_address
      @mfa_enabled = mfa_enabled == nil ? false : mfa_enabled
      @mfa_provider = mfa_provider == nil ? "" : mfa_provider
      @name = name == nil ? "" : name
      @require_secret_store = require_secret_store == nil ? false : require_secret_store
      @saml_metadata_url = saml_metadata_url == nil ? "" : saml_metadata_url
      @scim_provider = scim_provider == nil ? "" : scim_provider
      @sensitive_label = sensitive_label == nil ? "" : sensitive_label
      @session_timeout = session_timeout == nil ? nil : session_timeout
      @session_timeout_enabled = session_timeout_enabled == nil ? false : session_timeout_enabled
      @ssh_certificate_authority_public_key = ssh_certificate_authority_public_key == nil ? "" : ssh_certificate_authority_public_key
      @ssh_certificate_authority_updated_at = ssh_certificate_authority_updated_at == nil ? nil : ssh_certificate_authority_updated_at
      @updated_at = updated_at == nil ? nil : updated_at
      @websites_subdomain = websites_subdomain == nil ? "" : websites_subdomain
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # OrganizationHistoryRecord records the state of an Organization at a given point in time,
  # where every change to an Organization produces an OrganizationHistoryRecord.
  class OrganizationHistoryRecord
    # The unique identifier of the Activity that produced this change to the Organization.
    # May be empty for some system-initiated organization updates.
    attr_accessor :activity_id
    # The complete Organization state at this time.
    attr_accessor :organization
    # The time at which the Organization state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      organization: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @organization = organization == nil ? nil : organization
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroups are the building blocks used for explicit network topology making.
  # They may be linked to other peering groups. Sets of PeeringGroupResource and PeeringGroupNode can be attached to a peering group.
  class PeeringGroup
    # Unique identifier of the PeeringGroup.
    attr_accessor :id
    # Unique human-readable name of the PeeringGroup.
    attr_accessor :name

    def initialize(
      id: nil,
      name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupCreateResponse reports how the PeeringGroup was created in the system.
  class PeeringGroupCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroup.
    attr_accessor :peering_group
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group = peering_group == nil ? nil : peering_group
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupDeleteResponse returns information about a PeeringGroup that was deleted.
  class PeeringGroupDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupGetResponse returns a requested PeeringGroup.
  class PeeringGroupGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroup.
    attr_accessor :peering_group
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group = peering_group == nil ? nil : peering_group
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNode represents the attachment between a PeeringGroup and a Node.
  class PeeringGroupNode
    # Peering Group ID to which the node will be attached to.
    attr_accessor :group_id
    # Unique identifier of the Attachment.
    attr_accessor :id
    # Node ID to be attached.
    attr_accessor :node_id

    def initialize(
      group_id: nil,
      id: nil,
      node_id: nil
    )
      @group_id = group_id == nil ? "" : group_id
      @id = id == nil ? "" : id
      @node_id = node_id == nil ? "" : node_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNodeCreateResponse reports how the PeeringGroupNode was created in the system.
  class PeeringGroupNodeCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroupNode.
    attr_accessor :peering_group_node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_node = peering_group_node == nil ? nil : peering_group_node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNodeDeleteResponse returns information about a PeeringGroupNode that was deleted.
  class PeeringGroupNodeDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupNodeGetResponse returns a requested PeeringGroupNode.
  class PeeringGroupNodeGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroupNode.
    attr_accessor :peering_group_node
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_node: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_node = peering_group_node == nil ? nil : peering_group_node
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeer represents the link between two PeeringGroups
  class PeeringGroupPeer
    # Group ID from which the link will originate.
    attr_accessor :group_id
    # Unique identifier of the Attachment.
    attr_accessor :id
    # Peering Group ID to which Group ID will link.
    attr_accessor :peers_with_group_id

    def initialize(
      group_id: nil,
      id: nil,
      peers_with_group_id: nil
    )
      @group_id = group_id == nil ? "" : group_id
      @id = id == nil ? "" : id
      @peers_with_group_id = peers_with_group_id == nil ? "" : peers_with_group_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeerCreateResponse reports how the PeeringGroupPeer was created in the system.
  class PeeringGroupPeerCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroupPeer.
    attr_accessor :peering_group_peer
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_peer: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_peer = peering_group_peer == nil ? nil : peering_group_peer
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeerDeleteResponse returns information about a PeeringGroupPeer that was deleted.
  class PeeringGroupPeerDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupPeerGetResponse returns a requested PeeringGroupPeer.
  class PeeringGroupPeerGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroupPeer.
    attr_accessor :peering_group_peer
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_peer: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_peer = peering_group_peer == nil ? nil : peering_group_peer
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResource represents the attachment between a PeeringGroup and a Resource.
  class PeeringGroupResource
    # Peering Group ID to which the resource will be attached to.
    attr_accessor :group_id
    # Unique identifier of the Attachment.
    attr_accessor :id
    # Resource ID to be attached.
    attr_accessor :resource_id

    def initialize(
      group_id: nil,
      id: nil,
      resource_id: nil
    )
      @group_id = group_id == nil ? "" : group_id
      @id = id == nil ? "" : id
      @resource_id = resource_id == nil ? "" : resource_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResourceCreateResponse reports how the attachment was created in the system.
  class PeeringGroupResourceCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # The created PeeringGroupResource.
    attr_accessor :peering_group_resource
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_resource: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_resource = peering_group_resource == nil ? nil : peering_group_resource
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResourceDeleteResponse returns information about a PeeringGroupResource that was deleted.
  class PeeringGroupResourceDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # PeeringGroupResourceGetResponse returns a requested PeeringGroupResource.
  class PeeringGroupResourceGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # The requested PeeringGroupResource.
    attr_accessor :peering_group_resource
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      peering_group_resource: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @peering_group_resource = peering_group_resource == nil ? nil : peering_group_resource
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Postgres
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Presto
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Query is a record of a single client request to a resource, such as a SQL query.
  # Longer-running queries including long-running SSH commands and SSH, RDP, or Kubernetes
  # interactive sessions will return two Query records with the same identifier, one record
  # at the start of the query and a second record upon the completion of the query with
  # additional detail.
  class Query
    # The email of the account performing this query, at the time the query was executed.
    # If the account email is later changed, that change will not be reflected via this field.
    attr_accessor :account_email
    # The given name of the account performing this query, at the time the query was executed.
    # If the account is later renamed, that change will not be reflected via this field.
    attr_accessor :account_first_name
    # Unique identifier of the Account that performed the Query.
    attr_accessor :account_id
    # The family name of the account performing this query, at the time the query was executed.
    # If the account is later renamed, that change will not be reflected via this field.
    attr_accessor :account_last_name
    # The tags of the account accessed, at the time the query was executed. If the account
    # tags are later changed, that change will not be reflected via this field.
    attr_accessor :account_tags
    # For queries against SSH, Kubernetes, and RDP resources, this contains additional information
    # about the captured query.
    attr_accessor :capture
    # The time at which the Query was completed.
    # Empty if this record indicates the start of a long-running query.
    attr_accessor :completed_at
    # The duration of the Query.
    attr_accessor :duration
    # The unique ID of the node through which the Resource was accessed.
    attr_accessor :egress_node_id
    # Indicates that the body of the Query is encrypted.
    attr_accessor :encrypted
    # Unique identifier of the Query.
    attr_accessor :id
    # The captured content of the Query.
    # For queries against SSH, Kubernetes, and RDP resources, this contains a JSON representation of the QueryCapture.
    attr_accessor :query_body
    # The general category of Resource against which Query was performed, e.g. "web" or "cloud".
    attr_accessor :query_category
    # The hash of the body of the Query.
    attr_accessor :query_hash
    # The symmetric key used to encrypt the body of this Query and its replay if replayable.
    # If the Query is encrypted, this field contains an encrypted symmetric key in base64 encoding.
    # This key must be decrypted with the organization's private key to obtain the symmetric key needed to decrypt the body.
    # If the Query is not encrypted, this field is empty.
    attr_accessor :query_key
    # The number of records returned by the Query, for a database Resource.
    attr_accessor :record_count
    # The username of the RemoteIdentity used to access the Resource.
    attr_accessor :remote_identity_username
    # Indicates that the Query is replayable, e.g. for some SSH or K8s sessions.
    attr_accessor :replayable
    # Unique identifier of the Resource against which the Query was performed.
    attr_accessor :resource_id
    # The name of the resource accessed, at the time the query was executed. If the resource
    # is later renamed, that change will not be reflected via this field.
    attr_accessor :resource_name
    # The tags of the resource accessed, at the time the query was executed. If the resource
    # tags are later changed, that change will not be reflected via this field.
    attr_accessor :resource_tags
    # The specific type of Resource against which the Query was performed, e.g. "ssh" or "postgres".
    attr_accessor :resource_type
    # The IP address the Query was performed from, as detected at the ingress gateway.
    attr_accessor :source_ip
    # The time at which the Query was started.
    attr_accessor :timestamp

    def initialize(
      account_email: nil,
      account_first_name: nil,
      account_id: nil,
      account_last_name: nil,
      account_tags: nil,
      capture: nil,
      completed_at: nil,
      duration: nil,
      egress_node_id: nil,
      encrypted: nil,
      id: nil,
      query_body: nil,
      query_category: nil,
      query_hash: nil,
      query_key: nil,
      record_count: nil,
      remote_identity_username: nil,
      replayable: nil,
      resource_id: nil,
      resource_name: nil,
      resource_tags: nil,
      resource_type: nil,
      source_ip: nil,
      timestamp: nil
    )
      @account_email = account_email == nil ? "" : account_email
      @account_first_name = account_first_name == nil ? "" : account_first_name
      @account_id = account_id == nil ? "" : account_id
      @account_last_name = account_last_name == nil ? "" : account_last_name
      @account_tags = account_tags == nil ? SDM::_porcelain_zero_value_tags() : account_tags
      @capture = capture == nil ? nil : capture
      @completed_at = completed_at == nil ? nil : completed_at
      @duration = duration == nil ? nil : duration
      @egress_node_id = egress_node_id == nil ? "" : egress_node_id
      @encrypted = encrypted == nil ? false : encrypted
      @id = id == nil ? "" : id
      @query_body = query_body == nil ? "" : query_body
      @query_category = query_category == nil ? "" : query_category
      @query_hash = query_hash == nil ? "" : query_hash
      @query_key = query_key == nil ? "" : query_key
      @record_count = record_count == nil ? 0 : record_count
      @remote_identity_username = remote_identity_username == nil ? "" : remote_identity_username
      @replayable = replayable == nil ? false : replayable
      @resource_id = resource_id == nil ? "" : resource_id
      @resource_name = resource_name == nil ? "" : resource_name
      @resource_tags = resource_tags == nil ? SDM::_porcelain_zero_value_tags() : resource_tags
      @resource_type = resource_type == nil ? "" : resource_type
      @source_ip = source_ip == nil ? "" : source_ip
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A QueryCapture contains additional information about queries against SSH, Kubernetes, and RDP resources.
  class QueryCapture
    # The command executed on the client for a Kubernetes session.
    attr_accessor :client_command
    # The command executed over an SSH or Kubernetes session.
    attr_accessor :command
    # The target container of a Kubernetes operation.
    attr_accessor :container
    # The environment variables for an SSH or Kubernetes session.
    attr_accessor :env
    # The remote file name of an SCP operation.
    attr_accessor :file_name
    # The file size transferred for an SCP operation.
    attr_accessor :file_size
    # The height of the terminal or window for SSH, Kubernetes, and RDP interactive sessions.
    attr_accessor :height
    # The target pod of a Kubernetes operation.
    attr_accessor :pod
    # The HTTP request body of a Kubernetes operation.
    attr_accessor :request_body
    # The HTTP request method of a Kubernetes operation.
    attr_accessor :request_method
    # The HTTP request URI of a Kubernetes operation.
    attr_accessor :request_uri
    # The CaptureType of this query capture.
    attr_accessor :type
    # The width of the terminal or window for SSH, Kubernetes, and RDP interactive sessions.
    attr_accessor :width

    def initialize(
      client_command: nil,
      command: nil,
      container: nil,
      env: nil,
      file_name: nil,
      file_size: nil,
      height: nil,
      pod: nil,
      request_body: nil,
      request_method: nil,
      request_uri: nil,
      type: nil,
      width: nil
    )
      @client_command = client_command == nil ? "" : client_command
      @command = command == nil ? "" : command
      @container = container == nil ? "" : container
      @env = env == nil ? {} : env
      @file_name = file_name == nil ? "" : file_name
      @file_size = file_size == nil ? 0 : file_size
      @height = height == nil ? 0 : height
      @pod = pod == nil ? "" : pod
      @request_body = request_body == nil ? "" : request_body
      @request_method = request_method == nil ? "" : request_method
      @request_uri = request_uri == nil ? "" : request_uri
      @type = type == nil ? "" : type
      @width = width == nil ? 0 : width
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RDP
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
    attr_accessor :downgrade_nla_connections
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      downgrade_nla_connections: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @downgrade_nla_connections = downgrade_nla_connections == nil ? false : downgrade_nla_connections
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RabbitMQAMQP091
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RateLimitMetadata contains information about remaining requests avaialable
  # to the user over some timeframe.
  class RateLimitMetadata
    # The bucket this user/token is associated with, which may be shared between
    # multiple users/tokens.
    attr_accessor :bucket
    # How many total requests the user/token is authorized to make before being
    # rate limited.
    attr_accessor :limit
    # How many remaining requests out of the limit are still avaialable.
    attr_accessor :remaining
    # The time when remaining will be reset to limit.
    attr_accessor :reset_at

    def initialize(
      bucket: nil,
      limit: nil,
      remaining: nil,
      reset_at: nil
    )
      @bucket = bucket == nil ? "" : bucket
      @limit = limit == nil ? 0 : limit
      @remaining = remaining == nil ? 0 : remaining
      @reset_at = reset_at == nil ? nil : reset_at
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class RawTCP
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redis
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If set, TLS must be used to connect to this resource.
    attr_accessor :tls_required
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tls_required: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tls_required = tls_required == nil ? false : tls_required
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Redshift
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Relay represents a StrongDM CLI installation running in relay mode.
  class Relay
    # Device is a read only device name uploaded by the gateway process when
    # it comes online.
    attr_accessor :device
    # GatewayFilter can be used to restrict the peering between relays and
    # gateways. Deprecated.
    attr_accessor :gateway_filter
    # Unique identifier of the Relay.
    attr_accessor :id
    # Location is a read only network location uploaded by the gateway process
    # when it comes online.
    attr_accessor :location
    # Maintenance Windows define when this node is allowed to restart. If a node
    # is requested to restart, it will check each window to determine if any of
    # them permit it to restart, and if any do, it will. This check is repeated
    # per window until the restart is successfully completed.
    #
    # If not set here, may be set on the command line or via an environment variable
    # on the process itself; any server setting will take precedence over local
    # settings. This setting is ineffective for nodes below version 38.44.0.
    #
    # If this setting is not applied via this remote configuration or via local
    # configuration, the default setting is used: always allow restarts if serving
    # no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
    attr_accessor :maintenance_windows
    # Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    attr_accessor :name
    # The current state of the relay. One of: "new", "verifying_restart",
    # "awaiting_restart", "restarting", "started", "stopped", "dead",
    # "unknown".
    attr_accessor :state
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # Version is a read only sdm binary version uploaded by the gateway process
    # when it comes online.
    attr_accessor :version

    def initialize(
      device: nil,
      gateway_filter: nil,
      id: nil,
      location: nil,
      maintenance_windows: nil,
      name: nil,
      state: nil,
      tags: nil,
      version: nil
    )
      @device = device == nil ? "" : device
      @gateway_filter = gateway_filter == nil ? "" : gateway_filter
      @id = id == nil ? "" : id
      @location = location == nil ? "" : location
      @maintenance_windows = maintenance_windows == nil ? [] : maintenance_windows
      @name = name == nil ? "" : name
      @state = state == nil ? "" : state
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @version = version == nil ? "" : version
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentities define the username to be used for a specific account
  # when connecting to a remote resource using that group.
  class RemoteIdentity
    # The account for this remote identity.
    attr_accessor :account_id
    # Unique identifier of the RemoteIdentity.
    attr_accessor :id
    # The remote identity group.
    attr_accessor :remote_identity_group_id
    # The username to be used as the remote identity for this account.
    attr_accessor :username

    def initialize(
      account_id: nil,
      id: nil,
      remote_identity_group_id: nil,
      username: nil
    )
      @account_id = account_id == nil ? "" : account_id
      @id = id == nil ? "" : id
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityCreateResponse reports how the RemoteIdentities were created in the system.
  class RemoteIdentityCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityDeleteResponse returns information about a RemoteIdentity that was deleted.
  class RemoteIdentityDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGetResponse returns a requested RemoteIdentity.
  class RemoteIdentityGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A RemoteIdentityGroup defines a group of remote identities.
  class RemoteIdentityGroup
    # Unique identifier of the RemoteIdentityGroup.
    attr_accessor :id
    # Unique human-readable name of the RemoteIdentityGroup.
    attr_accessor :name

    def initialize(
      id: nil,
      name: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGroupGetResponse returns a requested RemoteIdentityGroup.
  class RemoteIdentityGroupGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested RemoteIdentityGroup.
    attr_accessor :remote_identity_group

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity_group: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity_group = remote_identity_group == nil ? nil : remote_identity_group
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityGroupHistory records the state of a RemoteIdentityGroup at a given point in time,
  # where every change (create, update and delete) to a RemoteIdentityGroup produces an
  # RemoteIdentityGroupHistory record.
  class RemoteIdentityGroupHistory
    # The unique identifier of the Activity that produced this change to the RemoteIdentityGroup.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RemoteIdentityGroup was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RemoteIdentityGroup state at this time.
    attr_accessor :remote_identity_group
    # The time at which the RemoteIdentityGroup state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      remote_identity_group: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @remote_identity_group = remote_identity_group == nil ? nil : remote_identity_group
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityHistory records the state of a RemoteIdentity at a given point in time,
  # where every change (create, update and delete) to a RemoteIdentity produces an
  # RemoteIdentityHistory record.
  class RemoteIdentityHistory
    # The unique identifier of the Activity that produced this change to the RemoteIdentity.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RemoteIdentity was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RemoteIdentity state at this time.
    attr_accessor :remote_identity
    # The time at which the RemoteIdentity state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      remote_identity: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @remote_identity = remote_identity == nil ? nil : remote_identity
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RemoteIdentityUpdateResponse returns the fields of a RemoteIdentity after it has been updated by
  # a RemoteIdentityUpdateRequest.
  class RemoteIdentityUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated RemoteIdentity.
    attr_accessor :remote_identity

    def initialize(
      meta: nil,
      rate_limit: nil,
      remote_identity: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @remote_identity = remote_identity == nil ? nil : remote_identity
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A ReplayChunk represents a single "chunk" of data from the query replay.
  class ReplayChunk
    # The raw data of the ReplayChunk. The data is encrypted if the associated Query is encrypted.
    attr_accessor :data
    # The list of events of the ReplayChunk. If the Query is encrypted, this field is always empty
    # and the events can be obtained by decrypting the data using the QueryKey returned with the Query.
    attr_accessor :events

    def initialize(
      data: nil,
      events: nil
    )
      @data = data == nil ? "" : data
      @events = events == nil ? [] : events
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A ReplayChunkEvent represents a single event within a query replay.
  # The timing information included in each ReplayChunkEvent may be used to replay a session in real time.
  class ReplayChunkEvent
    # The raw data of the ReplayChunkEvent.
    attr_accessor :data
    # The time duration over which the data in this ReplayChunkEvent was transferred.
    attr_accessor :duration

    def initialize(
      data: nil,
      duration: nil
    )
      @data = data == nil ? "" : data
      @duration = duration == nil ? nil : duration
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceCreateResponse reports how the Resources were created in the system.
  class ResourceCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceDeleteResponse returns information about a Resource that was deleted.
  class ResourceDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceGetResponse returns a requested Resource.
  class ResourceGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceHistory records the state of a Resource at a given point in time,
  # where every change (create, update and delete) to a Resource produces an
  # ResourceHistory record.
  class ResourceHistory
    # The unique identifier of the Activity that produced this change to the Resource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Resource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Resource state at this time.
    attr_accessor :resource
    # The time at which the Resource state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      resource: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @resource = resource == nil ? nil : resource
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # ResourceUpdateResponse returns the fields of a Resource after it has been updated by
  # a ResourceUpdateRequest.
  class ResourceUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Resource.
    attr_accessor :resource

    def initialize(
      meta: nil,
      rate_limit: nil,
      resource: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @resource = resource == nil ? nil : resource
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Role has a list of access rules which determine which Resources the members
  # of the Role have access to. An Account can be a member of multiple Roles via
  # AccountAttachments.
  class Role
    # AccessRules is a list of access rules defining the resources this Role has access to.
    attr_accessor :access_rules
    # Unique identifier of the Role.
    attr_accessor :id
    # Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
    attr_accessor :managed_by
    # Unique human-readable name of the Role.
    attr_accessor :name
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      access_rules: nil,
      id: nil,
      managed_by: nil,
      name: nil,
      tags: nil
    )
      @access_rules = access_rules == nil ? SDM::_porcelain_zero_value_access_rules() : access_rules
      @id = id == nil ? "" : id
      @managed_by = managed_by == nil ? "" : managed_by
      @name = name == nil ? "" : name
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleCreateResponse reports how the Roles were created in the system. It can
  # communicate partial successes or failures.
  class RoleCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleDeleteResponse returns information about a Role that was deleted.
  class RoleDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleGetResponse returns a requested Role.
  class RoleGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleHistory records the state of a Role at a given point in time,
  # where every change (create, update and delete) to a Role produces an
  # RoleHistory record.
  class RoleHistory
    # The unique identifier of the Activity that produced this change to the Role.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Role was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete Role state at this time.
    attr_accessor :role
    # The time at which the Role state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      role: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @role = role == nil ? nil : role
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleResource represents an individual access grant of a Role to a Resource.
  class RoleResource
    # The most recent time at which access was granted. If access was granted,
    # revoked, and granted again, this will reflect the later time.
    attr_accessor :granted_at
    # The unique identifier of the Resource to which access is granted.
    attr_accessor :resource_id
    # The unique identifier of the Role to which access is granted.
    attr_accessor :role_id

    def initialize(
      granted_at: nil,
      resource_id: nil,
      role_id: nil
    )
      @granted_at = granted_at == nil ? nil : granted_at
      @resource_id = resource_id == nil ? "" : resource_id
      @role_id = role_id == nil ? "" : role_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleResourceHistory records the state of a RoleResource at a given point in time,
  # where every change (create or delete) to a RoleResource produces an
  # RoleResourceHistory record.
  class RoleResourceHistory
    # The unique identifier of the Activity that produced this change to the RoleResource.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this RoleResource was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete RoleResource state at this time.
    attr_accessor :role_resource
    # The time at which the RoleResource state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      role_resource: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @role_resource = role_resource == nil ? nil : role_resource
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # RoleUpdateResponse returns the fields of a Role after it has been updated by
  # a RoleUpdateRequest.
  class RoleUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated Role.
    attr_accessor :role

    def initialize(
      meta: nil,
      rate_limit: nil,
      role: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @role = role == nil ? nil : role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServer
    # Whether to allow deprecated encryption protocols to be used for this resource. For example,
    # TLS 1.0.
    attr_accessor :allow_deprecated_encryption
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks, and used for clients if Override Default Database is true.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The Schema to use to direct initial requests.
    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_encryption: nil,
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      password: nil,
      port: nil,
      port_override: nil,
      schema: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_encryption = allow_deprecated_encryption == nil ? false : allow_deprecated_encryption
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServerAzureAD
    # Whether to allow deprecated encryption protocols to be used for this resource. For example,
    # TLS 1.0.
    attr_accessor :allow_deprecated_encryption
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The Azure AD application (client) ID with which to authenticate.
    attr_accessor :client_id
    # The database for healthchecks, and used for clients if Override Default Database is true.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The Schema to use to direct initial requests.
    attr_accessor :schema
    # The Azure AD client secret (application password) with which to authenticate.
    attr_accessor :secret
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The Azure AD directory (tenant) ID with which to authenticate.
    attr_accessor :tenant_id

    def initialize(
      allow_deprecated_encryption: nil,
      bind_interface: nil,
      client_id: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      override_database: nil,
      port: nil,
      port_override: nil,
      schema: nil,
      secret: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      tenant_id: nil
    )
      @allow_deprecated_encryption = allow_deprecated_encryption == nil ? false : allow_deprecated_encryption
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @client_id = client_id == nil ? "" : client_id
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret = secret == nil ? "" : secret
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @tenant_id = tenant_id == nil ? "" : tenant_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SQLServerKerberosAD
    # Whether to allow deprecated encryption protocols to be used for this resource. For example,
    # TLS 1.0.
    attr_accessor :allow_deprecated_encryption
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks, and used for clients if Override Default Database is true.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
    attr_accessor :keytab
    # The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
    attr_accessor :krb_config
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
    attr_accessor :override_database
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The Active Directory domain (realm) to which the configured username belongs.
    attr_accessor :realm
    # The Schema to use to direct initial requests.
    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
    attr_accessor :server_spn
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_encryption: nil,
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      keytab: nil,
      krb_config: nil,
      name: nil,
      override_database: nil,
      port: nil,
      port_override: nil,
      realm: nil,
      schema: nil,
      secret_store_id: nil,
      server_spn: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_encryption = allow_deprecated_encryption == nil ? false : allow_deprecated_encryption
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @keytab = keytab == nil ? "" : keytab
      @krb_config = krb_config == nil ? "" : krb_config
      @name = name == nil ? "" : name
      @override_database = override_database == nil ? false : override_database
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @realm = realm == nil ? "" : realm
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @server_spn = server_spn == nil ? "" : server_spn
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSH
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The key type to use e.g. rsa-2048 or ed25519
    attr_accessor :key_type
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The public key to append to a server's authorized keys. This will be generated after resource creation.
    attr_accessor :public_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      key_type: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      public_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @key_type = key_type == nil ? "" : key_type
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @public_key = public_key == nil ? "" : public_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCert
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # The key type to use e.g. rsa-2048 or ed25519
    attr_accessor :key_type
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The ID of the remote identity group to use for remote identity connections.
    attr_accessor :remote_identity_group_id
    # The username to use for healthchecks, when clients otherwise connect with their own remote identity username.
    attr_accessor :remote_identity_healthcheck_username
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      key_type: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      remote_identity_group_id: nil,
      remote_identity_healthcheck_username: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @key_type = key_type == nil ? "" : key_type
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @remote_identity_group_id = remote_identity_group_id == nil ? "" : remote_identity_group_id
      @remote_identity_healthcheck_username = remote_identity_healthcheck_username == nil ? "" : remote_identity_healthcheck_username
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SSHCustomerKey
    # Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
    attr_accessor :allow_deprecated_key_exchanges
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # Whether port forwarding is allowed through this server.
    attr_accessor :port_forwarding
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The private key used to authenticate with the server.
    attr_accessor :private_key
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      allow_deprecated_key_exchanges: nil,
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      port: nil,
      port_forwarding: nil,
      port_override: nil,
      private_key: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @allow_deprecated_key_exchanges = allow_deprecated_key_exchanges == nil ? false : allow_deprecated_key_exchanges
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port = port == nil ? 0 : port
      @port_forwarding = port_forwarding == nil ? false : port_forwarding
      @port_override = port_override == nil ? 0 : port_override
      @private_key = private_key == nil ? "" : private_key
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreCreateResponse reports how the SecretStores were created in the system.
  class SecretStoreCreateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The created SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreDeleteResponse returns information about a SecretStore that was deleted.
  class SecretStoreDeleteResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      meta: nil,
      rate_limit: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreGetResponse returns a requested SecretStore.
  class SecretStoreGetResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The requested SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreHistory records the state of a SecretStore at a given point in time,
  # where every change (create, update and delete) to a SecretStore produces an
  # SecretStoreHistory record.
  class SecretStoreHistory
    # The unique identifier of the Activity that produced this change to the SecretStore.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this SecretStore was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The complete SecretStore state at this time.
    attr_accessor :secret_store
    # The time at which the SecretStore state was recorded.
    attr_accessor :timestamp

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      secret_store: nil,
      timestamp: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @secret_store = secret_store == nil ? nil : secret_store
      @timestamp = timestamp == nil ? nil : timestamp
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # SecretStoreUpdateResponse returns the fields of a SecretStore after it has been updated by
  # a SecretStoreUpdateRequest.
  class SecretStoreUpdateResponse
    # Reserved for future use.
    attr_accessor :meta
    # Rate limit information.
    attr_accessor :rate_limit
    # The updated SecretStore.
    attr_accessor :secret_store

    def initialize(
      meta: nil,
      rate_limit: nil,
      secret_store: nil
    )
      @meta = meta == nil ? nil : meta
      @rate_limit = rate_limit == nil ? nil : rate_limit
      @secret_store = secret_store == nil ? nil : secret_store
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A Service is a service account that can connect to resources they are granted
  # directly, or granted via roles. Services are typically automated jobs.
  class Service
    # Unique identifier of the Service.
    attr_accessor :id
    # Unique human-readable name of the Service.
    attr_accessor :name
    # The Service's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      suspended: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SingleStore
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The database for healthchecks. Does not affect client requests.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
    attr_accessor :require_native_auth
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # If true, appends the hostname to the username when hitting a database.azure.com address
    attr_accessor :use_azure_single_server_usernames
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      require_native_auth: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      use_azure_single_server_usernames: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @require_native_auth = require_native_auth == nil ? false : require_native_auth
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @use_azure_single_server_usernames = use_azure_single_server_usernames == nil ? false : use_azure_single_server_usernames
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Snowflake
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The schema to provide on authentication.
    attr_accessor :schema
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port_override: nil,
      schema: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port_override = port_override == nil ? 0 : port_override
      @schema = schema == nil ? "" : schema
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Snowsight is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class Snowsight
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # The StrongDM user email to use for healthchecks.
    attr_accessor :healthcheck_username
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # The Metadata for your snowflake IDP integration
    attr_accessor :samlmetadata
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthcheck_username: nil,
      healthy: nil,
      id: nil,
      name: nil,
      port_override: nil,
      samlmetadata: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthcheck_username = healthcheck_username == nil ? "" : healthcheck_username
      @healthy = healthy == nil ? false : healthy
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @port_override = port_override == nil ? 0 : port_override
      @samlmetadata = samlmetadata == nil ? "" : samlmetadata
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Sybase
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class SybaseIQ
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Tag
    # The name or key of this tag. Each name can only refer to one value on a tagged entity.
    attr_accessor :name
    # The value of this tag.
    attr_accessor :value

    def initialize(
      name: nil,
      value: nil
    )
      @name = name == nil ? "" : name
      @value = value == nil ? "" : value
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class Teradata
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Trino is currently unstable, and its API may change, or it may be removed, without a major version bump.
  class Trino
    # The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
    attr_accessor :bind_interface
    # The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
    attr_accessor :database
    # A filter applied to the routing logic to pin datasource to nodes.
    attr_accessor :egress_filter
    # True if the datasource is reachable and the credentials are valid.
    attr_accessor :healthy
    # The host to dial to initiate a connection from the egress node to this resource.
    attr_accessor :hostname
    # Unique identifier of the Resource.
    attr_accessor :id
    # Unique human-readable name of the Resource.
    attr_accessor :name
    # The password to authenticate with.
    attr_accessor :password
    # The port to dial to initiate a connection from the egress node to this resource.
    attr_accessor :port
    # The local port used by clients to connect to this resource.
    attr_accessor :port_override
    # ID of the secret store containing credentials for this resource, if any.
    attr_accessor :secret_store_id
    # Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
    attr_accessor :subdomain
    # Tags is a map of key, value pairs.
    attr_accessor :tags
    # The username to authenticate with.
    attr_accessor :username

    def initialize(
      bind_interface: nil,
      database: nil,
      egress_filter: nil,
      healthy: nil,
      hostname: nil,
      id: nil,
      name: nil,
      password: nil,
      port: nil,
      port_override: nil,
      secret_store_id: nil,
      subdomain: nil,
      tags: nil,
      username: nil
    )
      @bind_interface = bind_interface == nil ? "" : bind_interface
      @database = database == nil ? "" : database
      @egress_filter = egress_filter == nil ? "" : egress_filter
      @healthy = healthy == nil ? false : healthy
      @hostname = hostname == nil ? "" : hostname
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @password = password == nil ? "" : password
      @port = port == nil ? 0 : port
      @port_override = port_override == nil ? 0 : port_override
      @secret_store_id = secret_store_id == nil ? "" : secret_store_id
      @subdomain = subdomain == nil ? "" : subdomain
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
      @username = username == nil ? "" : username
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # UpdateResponseMetadata is reserved for future use.
  class UpdateResponseMetadata
    def initialize()
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # A User can connect to resources they are granted directly, or granted
  # via roles.
  class User
    # The User's email address. Must be unique.
    attr_accessor :email
    # External ID is an alternative unique ID this user is represented by within an external service.
    attr_accessor :external_id
    # The User's first name.
    attr_accessor :first_name
    # Unique identifier of the User.
    attr_accessor :id
    # The User's last name.
    attr_accessor :last_name
    # Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
    attr_accessor :managed_by
    # PermissionLevel is a read only field for the user's permission level e.g. admin, DBA, user.
    attr_accessor :permission_level
    # The User's suspended state.
    attr_accessor :suspended
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      email: nil,
      external_id: nil,
      first_name: nil,
      id: nil,
      last_name: nil,
      managed_by: nil,
      permission_level: nil,
      suspended: nil,
      tags: nil
    )
      @email = email == nil ? "" : email
      @external_id = external_id == nil ? "" : external_id
      @first_name = first_name == nil ? "" : first_name
      @id = id == nil ? "" : id
      @last_name = last_name == nil ? "" : last_name
      @managed_by = managed_by == nil ? "" : managed_by
      @permission_level = permission_level == nil ? "" : permission_level
      @suspended = suspended == nil ? false : suspended
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultAppRoleStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTLSStore
    # A path to a CA file accessible by a Node
    attr_accessor :ca_cert_path
    # A path to a client certificate file accessible by a Node
    attr_accessor :client_cert_path
    # A path to a client key file accessible by a Node
    attr_accessor :client_key_path
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      ca_cert_path: nil,
      client_cert_path: nil,
      client_key_path: nil,
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @ca_cert_path = ca_cert_path == nil ? "" : ca_cert_path
      @client_cert_path = client_cert_path == nil ? "" : client_cert_path
      @client_key_path = client_key_path == nil ? "" : client_key_path
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  class VaultTokenStore
    # Unique identifier of the SecretStore.
    attr_accessor :id
    # Unique human-readable name of the SecretStore.
    attr_accessor :name
    # The namespace to make requests within
    attr_accessor :namespace
    # The URL of the Vault to target
    attr_accessor :server_address
    # Tags is a map of key, value pairs.
    attr_accessor :tags

    def initialize(
      id: nil,
      name: nil,
      namespace: nil,
      server_address: nil,
      tags: nil
    )
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @namespace = namespace == nil ? "" : namespace
      @server_address = server_address == nil ? "" : server_address
      @tags = tags == nil ? SDM::_porcelain_zero_value_tags() : tags
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # Workflows are the collection of rules that define the resources to which access can be requested,
  # the users that can request that access, and the mechanism for approving those requests which can either
  # but automatic approval or a set of users authorized to approve the requests.
  class Workflow
    # AccessRules is a list of access rules defining the resources this Workflow provides access to.
    attr_accessor :access_rules
    # Optional auto grant setting to automatically approve requests or not, defaults to false.
    attr_accessor :auto_grant
    # Optional description of the Workflow.
    attr_accessor :description
    # Optional enabled state for workflow. This setting may be overridden by the system if
    # the workflow doesn't meet the requirements to be enabled or if other conditions prevent
    # enabling the workflow.
    attr_accessor :enabled
    # Unique identifier of the Workflow.
    attr_accessor :id
    # Unique human-readable name of the Workflow.
    attr_accessor :name
    # Optional weight for workflow to specify it's priority in matching a request.
    attr_accessor :weight

    def initialize(
      access_rules: nil,
      auto_grant: nil,
      description: nil,
      enabled: nil,
      id: nil,
      name: nil,
      weight: nil
    )
      @access_rules = access_rules == nil ? SDM::_porcelain_zero_value_access_rules() : access_rules
      @auto_grant = auto_grant == nil ? false : auto_grant
      @description = description == nil ? "" : description
      @enabled = enabled == nil ? false : enabled
      @id = id == nil ? "" : id
      @name = name == nil ? "" : name
      @weight = weight == nil ? 0 : weight
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApprover is an account with the ability to approve requests bound to a workflow.
  class WorkflowApprover
    # The approver id.
    attr_accessor :approver_id
    # The workflow id.
    attr_accessor :workflow_id

    def initialize(
      approver_id: nil,
      workflow_id: nil
    )
      @approver_id = approver_id == nil ? "" : approver_id
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowApproverHistory records the state of a WorkflowApprover at a given point in time,
  # where every change (create, update and delete) to a WorkflowApprover produces an
  # WorkflowApproverHistory record.
  class WorkflowApproverHistory
    # The unique identifier of the Activity that produced this change to the Workflow.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Workflow state was recorded.
    attr_accessor :timestamp
    # The complete WorkflowApprover state at this time.
    attr_accessor :workflow_approver

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow_approver: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow_approver = workflow_approver == nil ? nil : workflow_approver
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowAssignment links a Resource to a Workflow.
  class WorkflowAssignment
    # The resource id.
    attr_accessor :resource_id
    # The workflow id.
    attr_accessor :workflow_id

    def initialize(
      resource_id: nil,
      workflow_id: nil
    )
      @resource_id = resource_id == nil ? "" : resource_id
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowAssignmentHistory records the state of a WorkflowAssignment at a given point in time,
  # where every change (create, update and delete) to a WorkflowAssignment produces an
  # WorkflowAssignmentHistory record.
  class WorkflowAssignmentHistory
    # The unique identifier of the Activity that produced this change to the Workflow.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Workflow state was recorded.
    attr_accessor :timestamp
    # The complete WorkflowAssignment state at this time.
    attr_accessor :workflow_assignment

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow_assignment: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow_assignment = workflow_assignment == nil ? nil : workflow_assignment
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowHistory records the state of a Workflow at a given point in time,
  # where every change (create, update and delete) to a Workflow produces an
  # WorkflowHistory record.
  class WorkflowHistory
    # The unique identifier of the Activity that produced this change to the Workflow.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this Workflow was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Workflow state was recorded.
    attr_accessor :timestamp
    # The complete Workflow state at this time.
    attr_accessor :workflow

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow = workflow == nil ? nil : workflow
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowListRequest specifies criteria for retrieving a list of
  # Workflow records
  class WorkflowListRequest
    # A human-readable filter query string.
    attr_accessor :filter

    def initialize(
      filter: nil
    )
      @filter = filter == nil ? "" : filter
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowListResponse returns a list of Workflow records that meet
  # the criteria of a WorkflowListRequest.
  class WorkflowListResponse
    # Rate limit information.
    attr_accessor :rate_limit

    def initialize(
      rate_limit: nil
    )
      @rate_limit = rate_limit == nil ? nil : rate_limit
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRole links a Role to a Workflow.
  class WorkflowRole
    # The role id.
    attr_accessor :role_id
    # The workflow id.
    attr_accessor :workflow_id

    def initialize(
      role_id: nil,
      workflow_id: nil
    )
      @role_id = role_id == nil ? "" : role_id
      @workflow_id = workflow_id == nil ? "" : workflow_id
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # WorkflowRolesHistory records the state of a Workflow at a given point in time,
  # where every change (create, update and delete) to a WorkflowRole produces a
  # WorkflowRoleHistory record.
  class WorkflowRoleHistory
    # The unique identifier of the Activity that produced this change to the Workflow.
    # May be empty for some system-initiated updates.
    attr_accessor :activity_id
    # If this WorkflowRole was deleted, the time it was deleted.
    attr_accessor :deleted_at
    # The time at which the Workflow state was recorded.
    attr_accessor :timestamp
    # The complete WorkflowRole state at this time.
    attr_accessor :workflow_role

    def initialize(
      activity_id: nil,
      deleted_at: nil,
      timestamp: nil,
      workflow_role: nil
    )
      @activity_id = activity_id == nil ? "" : activity_id
      @deleted_at = deleted_at == nil ? nil : deleted_at
      @timestamp = timestamp == nil ? nil : timestamp
      @workflow_role = workflow_role == nil ? nil : workflow_role
    end

    def to_json(options = {})
      hash = {}
      self.instance_variables.each do |var|
        hash[var.id2name.delete_prefix("@")] = self.instance_variable_get var
      end
      hash.to_json
    end
  end

  # @private
  def self._porcelain_zero_value_tags()
    {}
  end
  # @private
  def self._porcelain_zero_value_access_rules()
    []
  end
end
