# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal Code generated by protogen. DO NOT EDIT.

this_dir = File.expand_path(File.dirname(__FILE__))
lib_dir = File.join(this_dir, "grpc")
$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)
require "grpc"
require "enumerator"
Dir[File.join(__dir__, "grpc", "*.rb")].each { |file| require file }
Dir[File.join(__dir__, "models", "*.rb")].each { |file| require file }

module SDM #:nodoc:
  # AccessRequests are requests for access to a resource that may match a Workflow.
  #
  # See {AccessRequest}.
  class AccessRequests
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccessRequests::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Lists existing access requests.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccessRequestListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccessRequests.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.access_requests.each do |plumbing_item|
            g.yield Plumbing::convert_access_request_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotAccessRequests exposes the read only methods of the AccessRequests
  # service for historical queries.
  class SnapshotAccessRequests
    extend Gem::Deprecate

    def initialize(access_requests)
      @access_requests = access_requests
    end

    # Lists existing access requests.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @access_requests.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # AccessRequestEventsHistory provides records of all changes to the state of an AccessRequest.
  #
  # See {AccessRequestEventHistory}.
  class AccessRequestEventsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccessRequestEventsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccessRequestEventHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccessRequestEventHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccessRequestEventsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_access_request_event_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # AccessRequestsHistory provides records of all changes to the state of an AccessRequest.
  #
  # See {AccessRequestHistory}.
  class AccessRequestsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccessRequestsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccessRequestHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccessRequestHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccessRequestsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_access_request_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # AccountAttachments assign an account to a role.
  #
  # See {AccountAttachment}.
  class AccountAttachments
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountAttachments::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new AccountAttachment.
    def create(
      account_attachment,
      deadline: nil
    )
      req = V1::AccountAttachmentCreateRequest.new()

      req.account_attachment = Plumbing::convert_account_attachment_to_plumbing(account_attachment)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("AccountAttachments.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountAttachmentCreateResponse.new()
      resp.account_attachment = Plumbing::convert_account_attachment_to_porcelain(plumbing_response.account_attachment)
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one AccountAttachment by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::AccountAttachmentGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("AccountAttachments.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountAttachmentGetResponse.new()
      resp.account_attachment = Plumbing::convert_account_attachment_to_porcelain(plumbing_response.account_attachment)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a AccountAttachment by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::AccountAttachmentDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("AccountAttachments.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountAttachmentDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of AccountAttachments matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountAttachmentListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountAttachments.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.account_attachments.each do |plumbing_item|
            g.yield Plumbing::convert_account_attachment_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotAccountAttachments exposes the read only methods of the AccountAttachments
  # service for historical queries.
  class SnapshotAccountAttachments
    extend Gem::Deprecate

    def initialize(account_attachments)
      @account_attachments = account_attachments
    end

    # Get reads one AccountAttachment by ID.
    def get(
      id,
      deadline: nil
    )
      return @account_attachments.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of AccountAttachments matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @account_attachments.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # AccountAttachmentsHistory records all changes to the state of an AccountAttachment.
  #
  # See {AccountAttachmentHistory}.
  class AccountAttachmentsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountAttachmentsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccountAttachmentHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountAttachmentHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountAttachmentsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_account_attachment_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # AccountGrants assign a resource directly to an account, giving the account the permission to connect to that resource.
  #
  # See {AccountGrant}.
  class AccountGrants
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountGrants::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new AccountGrant.
    def create(
      account_grant,
      deadline: nil
    )
      req = V1::AccountGrantCreateRequest.new()

      req.account_grant = Plumbing::convert_account_grant_to_plumbing(account_grant)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("AccountGrants.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGrantCreateResponse.new()
      resp.account_grant = Plumbing::convert_account_grant_to_porcelain(plumbing_response.account_grant)
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one AccountGrant by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::AccountGrantGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("AccountGrants.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGrantGetResponse.new()
      resp.account_grant = Plumbing::convert_account_grant_to_porcelain(plumbing_response.account_grant)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a AccountGrant by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::AccountGrantDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("AccountGrants.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGrantDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of AccountGrants matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountGrantListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountGrants.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.account_grants.each do |plumbing_item|
            g.yield Plumbing::convert_account_grant_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotAccountGrants exposes the read only methods of the AccountGrants
  # service for historical queries.
  class SnapshotAccountGrants
    extend Gem::Deprecate

    def initialize(account_grants)
      @account_grants = account_grants
    end

    # Get reads one AccountGrant by ID.
    def get(
      id,
      deadline: nil
    )
      return @account_grants.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of AccountGrants matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @account_grants.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # AccountGrantsHistory records all changes to the state of an AccountGrant.
  #
  # See {AccountGrantHistory}.
  class AccountGrantsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountGrantsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccountGrantHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountGrantHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountGrantsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_account_grant_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # AccountPermissions records the granular permissions accounts have, allowing them to execute
  # relevant commands via StrongDM's APIs.
  #
  # See {AccountPermission}.
  class AccountPermissions
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountPermissions::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of Permission records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountPermissionListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountPermissions.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.permissions.each do |plumbing_item|
            g.yield Plumbing::convert_account_permission_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotAccountPermissions exposes the read only methods of the AccountPermissions
  # service for historical queries.
  class SnapshotAccountPermissions
    extend Gem::Deprecate

    def initialize(account_permissions)
      @account_permissions = account_permissions
    end

    # List gets a list of Permission records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @account_permissions.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # AccountResources enumerates the resources to which accounts have access.
  # The AccountResources service is read-only.
  #
  # See {AccountResource}.
  class AccountResources
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountResources::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccountResource records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountResourceListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountResources.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.account_resources.each do |plumbing_item|
            g.yield Plumbing::convert_account_resource_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotAccountResources exposes the read only methods of the AccountResources
  # service for historical queries.
  class SnapshotAccountResources
    extend Gem::Deprecate

    def initialize(account_resources)
      @account_resources = account_resources
    end

    # List gets a list of AccountResource records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @account_resources.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # AccountResourcesHistory records all changes to the state of a AccountResource.
  #
  # See {AccountResourceHistory}.
  class AccountResourcesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountResourcesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccountResourceHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountResourceHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountResourcesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_account_resource_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # Accounts are users that have access to strongDM. There are two types of accounts:
  # 1. **Users:** humans who are authenticated through username and password or SSO.
  # 2. **Service Accounts:** machines that are authenticated using a service token.
  # 3. **Tokens** are access keys with permissions that can be used for authentication.
  #
  # See:
  # {Service}
  # {Token}
  # {User}
  class Accounts
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Accounts::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new Account.
    def create(
      account,
      deadline: nil
    )
      req = V1::AccountCreateRequest.new()

      req.account = Plumbing::convert_account_to_plumbing(account)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Accounts.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountCreateResponse.new()
      resp.access_key = (plumbing_response.access_key)
      resp.account = Plumbing::convert_account_to_porcelain(plumbing_response.account)
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_key = (plumbing_response.secret_key)
      resp.token = (plumbing_response.token)
      resp
    end

    # Get reads one Account by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::AccountGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Accounts.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGetResponse.new()
      resp.account = Plumbing::convert_account_to_porcelain(plumbing_response.account)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Update replaces all the fields of an Account by ID.
    def update(
      account,
      deadline: nil
    )
      req = V1::AccountUpdateRequest.new()

      req.account = Plumbing::convert_account_to_plumbing(account)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Accounts.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountUpdateResponse.new()
      resp.account = Plumbing::convert_account_to_porcelain(plumbing_response.account)
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes an Account by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::AccountDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Accounts.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Accounts matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Accounts.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.accounts.each do |plumbing_item|
            g.yield Plumbing::convert_account_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotAccounts exposes the read only methods of the Accounts
  # service for historical queries.
  class SnapshotAccounts
    extend Gem::Deprecate

    def initialize(accounts)
      @accounts = accounts
    end

    # Get reads one Account by ID.
    def get(
      id,
      deadline: nil
    )
      return @accounts.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of Accounts matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @accounts.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # AccountsHistory records all changes to the state of an Account.
  #
  # See {AccountHistory}.
  class AccountsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of AccountHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_account_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # An Activity is a record of an action taken against a strongDM deployment, e.g.
  # a user creation, resource deletion, sso configuration change, etc. The Activities
  # service is read-only.
  #
  # See {Activity}.
  class Activities
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Activities::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Get reads one Activity by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::ActivityGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Activities.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ActivityGetResponse.new()
      resp.activity = Plumbing::convert_activity_to_porcelain(plumbing_response.activity)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Activities matching a given set of criteria.
    # The 'before' and 'after' filters can be used to control the time
    # range of the output activities. If not provided, one week of back
    # of activities will be returned.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ActivityListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Activities.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.activities.each do |plumbing_item|
            g.yield Plumbing::convert_activity_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # ApprovalWorkflowApprovers link approval workflow approvers to an ApprovalWorkflowStep
  #
  # See {ApprovalWorkflowApprover}.
  class ApprovalWorkflowApprovers
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ApprovalWorkflowApprovers::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create creates a new approval workflow approver.
    def create(
      approval_workflow_approver,
      deadline: nil
    )
      req = V1::ApprovalWorkflowApproverCreateRequest.new()

      req.approval_workflow_approver = Plumbing::convert_approval_workflow_approver_to_plumbing(approval_workflow_approver)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("ApprovalWorkflowApprovers.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowApproverCreateResponse.new()
      resp.approval_workflow_approver = Plumbing::convert_approval_workflow_approver_to_porcelain(plumbing_response.approval_workflow_approver)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one approval workflow approver by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::ApprovalWorkflowApproverGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("ApprovalWorkflowApprovers.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowApproverGetResponse.new()
      resp.approval_workflow_approver = Plumbing::convert_approval_workflow_approver_to_porcelain(plumbing_response.approval_workflow_approver)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete deletes an existing approval workflow approver.
    def delete(
      id,
      deadline: nil
    )
      req = V1::ApprovalWorkflowApproverDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("ApprovalWorkflowApprovers.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowApproverDeleteResponse.new()
      resp.id = (plumbing_response.id)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Lists existing approval workflow approvers.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ApprovalWorkflowApproverListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ApprovalWorkflowApprovers.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.approval_workflow_approvers.each do |plumbing_item|
            g.yield Plumbing::convert_approval_workflow_approver_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotApprovalWorkflowApprovers exposes the read only methods of the ApprovalWorkflowApprovers
  # service for historical queries.
  class SnapshotApprovalWorkflowApprovers
    extend Gem::Deprecate

    def initialize(approval_workflow_approvers)
      @approval_workflow_approvers = approval_workflow_approvers
    end

    # Get reads one approval workflow approver by ID.
    def get(
      id,
      deadline: nil
    )
      return @approval_workflow_approvers.get(
               id,
               deadline: deadline,
             )
    end

    # Lists existing approval workflow approvers.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @approval_workflow_approvers.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # ApprovalWorkflowApproversHistory records all changes to the state of an ApprovalWorkflowApprover.
  #
  # See {ApprovalWorkflowApproverHistory}.
  class ApprovalWorkflowApproversHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ApprovalWorkflowApproversHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of ApprovalWorkflowApproverHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ApprovalWorkflowApproverHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ApprovalWorkflowApproversHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_approval_workflow_approver_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # ApprovalWorkflowSteps link approval workflow steps to an ApprovalWorkflow
  #
  # See {ApprovalWorkflowStep}.
  class ApprovalWorkflowSteps
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ApprovalWorkflowSteps::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create creates a new approval workflow step.
    def create(
      approval_workflow_step,
      deadline: nil
    )
      req = V1::ApprovalWorkflowStepCreateRequest.new()

      req.approval_workflow_step = Plumbing::convert_approval_workflow_step_to_plumbing(approval_workflow_step)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("ApprovalWorkflowSteps.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowStepCreateResponse.new()
      resp.approval_workflow_step = Plumbing::convert_approval_workflow_step_to_porcelain(plumbing_response.approval_workflow_step)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one approval workflow step by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::ApprovalWorkflowStepGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("ApprovalWorkflowSteps.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowStepGetResponse.new()
      resp.approval_workflow_step = Plumbing::convert_approval_workflow_step_to_porcelain(plumbing_response.approval_workflow_step)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete deletes an existing approval workflow step.
    def delete(
      id,
      deadline: nil
    )
      req = V1::ApprovalWorkflowStepDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("ApprovalWorkflowSteps.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowStepDeleteResponse.new()
      resp.id = (plumbing_response.id)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Lists existing approval workflow steps.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ApprovalWorkflowStepListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ApprovalWorkflowSteps.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.approval_workflow_steps.each do |plumbing_item|
            g.yield Plumbing::convert_approval_workflow_step_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotApprovalWorkflowSteps exposes the read only methods of the ApprovalWorkflowSteps
  # service for historical queries.
  class SnapshotApprovalWorkflowSteps
    extend Gem::Deprecate

    def initialize(approval_workflow_steps)
      @approval_workflow_steps = approval_workflow_steps
    end

    # Get reads one approval workflow step by ID.
    def get(
      id,
      deadline: nil
    )
      return @approval_workflow_steps.get(
               id,
               deadline: deadline,
             )
    end

    # Lists existing approval workflow steps.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @approval_workflow_steps.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # ApprovalWorkflowStepsHistory records all changes to the state of an ApprovalWorkflowStep.
  #
  # See {ApprovalWorkflowStepHistory}.
  class ApprovalWorkflowStepsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ApprovalWorkflowStepsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of ApprovalWorkflowStepHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ApprovalWorkflowStepHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ApprovalWorkflowStepsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_approval_workflow_step_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # ApprovalWorkflows are the mechanism by which requests for access can be viewed by authorized
  # approvers and be approved or denied.
  #
  # See {ApprovalWorkflow}.
  class ApprovalWorkflows
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ApprovalWorkflows::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create creates a new approval workflow and requires a name and approval mode for the approval workflow.
    def create(
      approval_workflow,
      deadline: nil
    )
      req = V1::ApprovalWorkflowCreateRequest.new()

      req.approval_workflow = Plumbing::convert_approval_workflow_to_plumbing(approval_workflow)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("ApprovalWorkflows.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowCreateResponse.new()
      resp.approval_workflow = Plumbing::convert_approval_workflow_to_porcelain(plumbing_response.approval_workflow)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one approval workflow by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::ApprovalWorkflowGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("ApprovalWorkflows.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowGetResponse.new()
      resp.approval_workflow = Plumbing::convert_approval_workflow_to_porcelain(plumbing_response.approval_workflow)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete deletes an existing approval workflow.
    def delete(
      id,
      deadline: nil
    )
      req = V1::ApprovalWorkflowDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("ApprovalWorkflows.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowDeleteResponse.new()
      resp.id = (plumbing_response.id)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Update updates an existing approval workflow.
    def update(
      approval_workflow,
      deadline: nil
    )
      req = V1::ApprovalWorkflowUpdateRequest.new()

      req.approval_workflow = Plumbing::convert_approval_workflow_to_plumbing(approval_workflow)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("ApprovalWorkflows.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ApprovalWorkflowUpdateResponse.new()
      resp.approval_workflow = Plumbing::convert_approval_workflow_to_porcelain(plumbing_response.approval_workflow)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Lists existing approval workflows.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ApprovalWorkflowListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ApprovalWorkflows.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.approval_workflows.each do |plumbing_item|
            g.yield Plumbing::convert_approval_workflow_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotApprovalWorkflows exposes the read only methods of the ApprovalWorkflows
  # service for historical queries.
  class SnapshotApprovalWorkflows
    extend Gem::Deprecate

    def initialize(approval_workflows)
      @approval_workflows = approval_workflows
    end

    # Get reads one approval workflow by ID.
    def get(
      id,
      deadline: nil
    )
      return @approval_workflows.get(
               id,
               deadline: deadline,
             )
    end

    # Lists existing approval workflows.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @approval_workflows.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # ApprovalWorkflowsHistory records all changes to the state of an ApprovalWorkflow.
  #
  # See {ApprovalWorkflowHistory}.
  class ApprovalWorkflowsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ApprovalWorkflowsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of ApprovalWorkflowHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ApprovalWorkflowHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ApprovalWorkflowsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_approval_workflow_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # ControlPanel contains all administrative controls.
  class ControlPanel
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ControlPanel::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # GetSSHCAPublicKey retrieves the SSH CA public key.
    def get_sshca_public_key(
      deadline: nil
    )
      req = V1::ControlPanelGetSSHCAPublicKeyRequest.new()

      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get_sshca_public_key(req, metadata: @parent.get_metadata("ControlPanel.GetSSHCAPublicKey", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ControlPanelGetSSHCAPublicKeyResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.public_key = (plumbing_response.public_key)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # GetRDPCAPublicKey retrieves the RDP CA public key.
    def get_rdpca_public_key(
      deadline: nil
    )
      req = V1::ControlPanelGetRDPCAPublicKeyRequest.new()

      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get_rdpca_public_key(req, metadata: @parent.get_metadata("ControlPanel.GetRDPCAPublicKey", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ControlPanelGetRDPCAPublicKeyResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.public_key = (plumbing_response.public_key)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # VerifyJWT reports whether the given JWT token (x-sdm-token) is valid.
    def verify_jwt(
      token,
      deadline: nil
    )
      req = V1::ControlPanelVerifyJWTRequest.new()

      req.token = (token)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.verify_jwt(req, metadata: @parent.get_metadata("ControlPanel.VerifyJWT", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ControlPanelVerifyJWTResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.valid = (plumbing_response.valid)
      resp
    end
  end

  # Nodes make up the strongDM network, and allow your users to connect securely to your resources. There are two types of nodes:
  # - **Gateways** are the entry points into network. They listen for connection from the strongDM client, and provide access to databases and servers.
  # - **Relays** are used to extend the strongDM network into segmented subnets. They provide access to databases and servers but do not listen for incoming connections.
  #
  # See:
  # {Gateway}
  # {Relay}
  class Nodes
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Nodes::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new Node.
    def create(
      node,
      deadline: nil
    )
      req = V1::NodeCreateRequest.new()

      req.node = Plumbing::convert_node_to_plumbing(node)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Nodes.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.node = Plumbing::convert_node_to_porcelain(plumbing_response.node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.token = (plumbing_response.token)
      resp
    end

    # Get reads one Node by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::NodeGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Nodes.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.node = Plumbing::convert_node_to_porcelain(plumbing_response.node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Update replaces all the fields of a Node by ID.
    def update(
      node,
      deadline: nil
    )
      req = V1::NodeUpdateRequest.new()

      req.node = Plumbing::convert_node_to_plumbing(node)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Nodes.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.node = Plumbing::convert_node_to_porcelain(plumbing_response.node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a Node by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::NodeDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Nodes.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Nodes matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::NodeListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Nodes.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.nodes.each do |plumbing_item|
            g.yield Plumbing::convert_node_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotNodes exposes the read only methods of the Nodes
  # service for historical queries.
  class SnapshotNodes
    extend Gem::Deprecate

    def initialize(nodes)
      @nodes = nodes
    end

    # Get reads one Node by ID.
    def get(
      id,
      deadline: nil
    )
      return @nodes.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of Nodes matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @nodes.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # NodesHistory records all changes to the state of a Node.
  #
  # See {NodeHistory}.
  class NodesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::NodesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of NodeHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::NodeHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("NodesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_node_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # OrganizationHistory records all changes to the state of an Organization.
  #
  # See {OrganizationHistoryRecord}.
  class OrganizationHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::OrganizationHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of OrganizationHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::OrganizationHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("OrganizationHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_organization_history_record_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # PeeringGroupNodes provides the building blocks necessary to obtain attach a node to a peering group.
  #
  # See {PeeringGroupNode}.
  class PeeringGroupNodes
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::PeeringGroupNodes::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create attaches a Node to a PeeringGroup
    def create(
      peering_group_node,
      deadline: nil
    )
      req = V1::PeeringGroupNodeCreateRequest.new()

      req.peering_group_node = Plumbing::convert_peering_group_node_to_plumbing(peering_group_node)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("PeeringGroupNodes.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupNodeCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group_node = Plumbing::convert_peering_group_node_to_porcelain(plumbing_response.peering_group_node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete detaches a Node to a PeeringGroup.
    def delete(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupNodeDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("PeeringGroupNodes.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupNodeDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads the information of one peering group to node attachment.
    def get(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupNodeGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("PeeringGroupNodes.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupNodeGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group_node = Plumbing::convert_peering_group_node_to_porcelain(plumbing_response.peering_group_node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of peering group node attachments.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::PeeringGroupNodeListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("PeeringGroupNodes.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.peering_group_nodes.each do |plumbing_item|
            g.yield Plumbing::convert_peering_group_node_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # PeeringGroupPeers provides the building blocks necessary to link two peering groups.
  #
  # See {PeeringGroupPeer}.
  class PeeringGroupPeers
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::PeeringGroupPeers::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create links two peering groups.
    def create(
      peering_group_peer,
      deadline: nil
    )
      req = V1::PeeringGroupPeerCreateRequest.new()

      req.peering_group_peer = Plumbing::convert_peering_group_peer_to_plumbing(peering_group_peer)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("PeeringGroupPeers.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupPeerCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group_peer = Plumbing::convert_peering_group_peer_to_porcelain(plumbing_response.peering_group_peer)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete unlinks two peering groups.
    def delete(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupPeerDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("PeeringGroupPeers.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupPeerDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads the information of one peering group link.
    def get(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupPeerGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("PeeringGroupPeers.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupPeerGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group_peer = Plumbing::convert_peering_group_peer_to_porcelain(plumbing_response.peering_group_peer)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of peering group links.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::PeeringGroupPeerListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("PeeringGroupPeers.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.peering_group_peers.each do |plumbing_item|
            g.yield Plumbing::convert_peering_group_peer_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # PeeringGroupResources provides the building blocks necessary to obtain attach a resource to a peering group.
  #
  # See {PeeringGroupResource}.
  class PeeringGroupResources
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::PeeringGroupResources::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create attaches a Resource to a PeeringGroup
    def create(
      peering_group_resource,
      deadline: nil
    )
      req = V1::PeeringGroupResourceCreateRequest.new()

      req.peering_group_resource = Plumbing::convert_peering_group_resource_to_plumbing(peering_group_resource)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("PeeringGroupResources.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupResourceCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group_resource = Plumbing::convert_peering_group_resource_to_porcelain(plumbing_response.peering_group_resource)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete detaches a Resource to a PeeringGroup
    def delete(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupResourceDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("PeeringGroupResources.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupResourceDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads the information of one peering group to resource attachment.
    def get(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupResourceGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("PeeringGroupResources.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupResourceGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group_resource = Plumbing::convert_peering_group_resource_to_porcelain(plumbing_response.peering_group_resource)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of peering group resource attachments.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::PeeringGroupResourceListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("PeeringGroupResources.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.peering_group_resources.each do |plumbing_item|
            g.yield Plumbing::convert_peering_group_resource_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # PeeringGroups provides the building blocks necessary to obtain explicit network topology and routing.
  #
  # See {PeeringGroup}.
  class PeeringGroups
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::PeeringGroups::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new PeeringGroup.
    def create(
      peering_group,
      deadline: nil
    )
      req = V1::PeeringGroupCreateRequest.new()

      req.peering_group = Plumbing::convert_peering_group_to_plumbing(peering_group)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("PeeringGroups.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group = Plumbing::convert_peering_group_to_porcelain(plumbing_response.peering_group)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a PeeringGroup by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("PeeringGroups.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one PeeringGroup by ID. It will load all its dependencies.
    def get(
      id,
      deadline: nil
    )
      req = V1::PeeringGroupGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("PeeringGroups.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = PeeringGroupGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.peering_group = Plumbing::convert_peering_group_to_porcelain(plumbing_response.peering_group)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Peering Groups.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::PeeringGroupListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("PeeringGroups.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.peering_groups.each do |plumbing_item|
            g.yield Plumbing::convert_peering_group_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # A Query is a record of a single client request to a resource, such as a SQL query.
  # Long-running SSH, RDP, or Kubernetes interactive sessions also count as queries.
  # The Queries service is read-only.
  #
  # See {Query}.
  class Queries
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Queries::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of Queries matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::QueryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Queries.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.queries.each do |plumbing_item|
            g.yield Plumbing::convert_query_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # RemoteIdentities assign a resource directly to an account, giving the account the permission to connect to that resource.
  #
  # See {RemoteIdentity}.
  class RemoteIdentities
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RemoteIdentities::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new RemoteIdentity.
    def create(
      remote_identity,
      deadline: nil
    )
      req = V1::RemoteIdentityCreateRequest.new()

      req.remote_identity = Plumbing::convert_remote_identity_to_plumbing(remote_identity)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("RemoteIdentities.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity = Plumbing::convert_remote_identity_to_porcelain(plumbing_response.remote_identity)
      resp
    end

    # Get reads one RemoteIdentity by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::RemoteIdentityGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("RemoteIdentities.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity = Plumbing::convert_remote_identity_to_porcelain(plumbing_response.remote_identity)
      resp
    end

    # Update replaces all the fields of a RemoteIdentity by ID.
    def update(
      remote_identity,
      deadline: nil
    )
      req = V1::RemoteIdentityUpdateRequest.new()

      req.remote_identity = Plumbing::convert_remote_identity_to_plumbing(remote_identity)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("RemoteIdentities.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity = Plumbing::convert_remote_identity_to_porcelain(plumbing_response.remote_identity)
      resp
    end

    # Delete removes a RemoteIdentity by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::RemoteIdentityDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("RemoteIdentities.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of RemoteIdentities matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RemoteIdentityListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RemoteIdentities.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.remote_identities.each do |plumbing_item|
            g.yield Plumbing::convert_remote_identity_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotRemoteIdentities exposes the read only methods of the RemoteIdentities
  # service for historical queries.
  class SnapshotRemoteIdentities
    extend Gem::Deprecate

    def initialize(remote_identities)
      @remote_identities = remote_identities
    end

    # Get reads one RemoteIdentity by ID.
    def get(
      id,
      deadline: nil
    )
      return @remote_identities.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of RemoteIdentities matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @remote_identities.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # RemoteIdentitiesHistory records all changes to the state of a RemoteIdentity.
  #
  # See {RemoteIdentityHistory}.
  class RemoteIdentitiesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RemoteIdentitiesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of RemoteIdentityHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RemoteIdentityHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RemoteIdentitiesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_remote_identity_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts.
  # An Account's relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
  #
  # See {RemoteIdentityGroup}.
  class RemoteIdentityGroups
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RemoteIdentityGroups::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Get reads one RemoteIdentityGroup by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::RemoteIdentityGroupGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("RemoteIdentityGroups.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityGroupGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity_group = Plumbing::convert_remote_identity_group_to_porcelain(plumbing_response.remote_identity_group)
      resp
    end

    # List gets a list of RemoteIdentityGroups matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RemoteIdentityGroupListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RemoteIdentityGroups.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.remote_identity_groups.each do |plumbing_item|
            g.yield Plumbing::convert_remote_identity_group_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotRemoteIdentityGroups exposes the read only methods of the RemoteIdentityGroups
  # service for historical queries.
  class SnapshotRemoteIdentityGroups
    extend Gem::Deprecate

    def initialize(remote_identity_groups)
      @remote_identity_groups = remote_identity_groups
    end

    # Get reads one RemoteIdentityGroup by ID.
    def get(
      id,
      deadline: nil
    )
      return @remote_identity_groups.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of RemoteIdentityGroups matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @remote_identity_groups.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # RemoteIdentityGroupsHistory records all changes to the state of a RemoteIdentityGroup.
  #
  # See {RemoteIdentityGroupHistory}.
  class RemoteIdentityGroupsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RemoteIdentityGroupsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of RemoteIdentityGroupHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RemoteIdentityGroupHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RemoteIdentityGroupsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_remote_identity_group_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # A Replay captures the data transferred over a long-running SSH, RDP, or Kubernetes interactive session
  # (otherwise referred to as a query). The Replays service is read-only.
  #
  # See {ReplayChunk}.
  class Replays
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Replays::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of ReplayChunks for the Query ID specified by the filter criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ReplayListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Replays.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.chunks.each do |plumbing_item|
            g.yield Plumbing::convert_replay_chunk_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # Resources are databases, servers, clusters, websites, or clouds that strongDM
  # delegates access to.
  #
  # See:
  # {AKS}
  # {AKSBasicAuth}
  # {AKSServiceAccount}
  # {AKSServiceAccountUserImpersonation}
  # {AKSUserImpersonation}
  # {AmazonEKS}
  # {AmazonEKSInstanceProfile}
  # {AmazonEKSInstanceProfileUserImpersonation}
  # {AmazonEKSUserImpersonation}
  # {AmazonES}
  # {AmazonMQAMQP091}
  # {Athena}
  # {AuroraMysql}
  # {AuroraPostgres}
  # {AuroraPostgresIAM}
  # {AWS}
  # {AWSConsole}
  # {AWSConsoleStaticKeyPair}
  # {Azure}
  # {AzureCertificate}
  # {AzureMysql}
  # {AzurePostgres}
  # {AzurePostgresManagedIdentity}
  # {BigQuery}
  # {Cassandra}
  # {Citus}
  # {Clustrix}
  # {Cockroach}
  # {DB2I}
  # {DB2LUW}
  # {DocumentDBHost}
  # {DocumentDBReplicaSet}
  # {Druid}
  # {DynamoDB}
  # {Elastic}
  # {ElasticacheRedis}
  # {GCP}
  # {GoogleGKE}
  # {GoogleGKEUserImpersonation}
  # {Greenplum}
  # {HTTPAuth}
  # {HTTPBasicAuth}
  # {HTTPNoAuth}
  # {Kubernetes}
  # {KubernetesBasicAuth}
  # {KubernetesServiceAccount}
  # {KubernetesServiceAccountUserImpersonation}
  # {KubernetesUserImpersonation}
  # {Maria}
  # {Memcached}
  # {Memsql}
  # {MongoHost}
  # {MongoLegacyHost}
  # {MongoLegacyReplicaset}
  # {MongoReplicaSet}
  # {MongoShardedCluster}
  # {MTLSMysql}
  # {MTLSPostgres}
  # {Mysql}
  # {Neptune}
  # {NeptuneIAM}
  # {Oracle}
  # {Postgres}
  # {Presto}
  # {RabbitMQAMQP091}
  # {RawTCP}
  # {RDP}
  # {RDPCert}
  # {RDSPostgresIAM}
  # {Redis}
  # {Redshift}
  # {SingleStore}
  # {Snowflake}
  # {Snowsight}
  # {SQLServer}
  # {SQLServerAzureAD}
  # {SQLServerKerberosAD}
  # {SSH}
  # {SSHCert}
  # {SSHCustomerKey}
  # {Sybase}
  # {SybaseIQ}
  # {Teradata}
  # {Trino}
  class Resources
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Resources::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # EnumerateTags gets a list of the filter matching tags.
    def enumerate_tags(
      filter,
      *args,
      deadline: nil
    )
      req = V1::EnumerateTagsRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.enumerate_tags(req, metadata: @parent.get_metadata("Resources.EnumerateTags", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.matches.each do |plumbing_item|
            g.yield Plumbing::convert_tag_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end

    # Create registers a new Resource.
    def create(
      resource,
      deadline: nil
    )
      req = V1::ResourceCreateRequest.new()

      req.resource = Plumbing::convert_resource_to_plumbing(resource)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Resources.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.resource = Plumbing::convert_resource_to_porcelain(plumbing_response.resource)
      resp
    end

    # Get reads one Resource by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::ResourceGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Resources.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.resource = Plumbing::convert_resource_to_porcelain(plumbing_response.resource)
      resp
    end

    # Update replaces all the fields of a Resource by ID.
    def update(
      resource,
      deadline: nil
    )
      req = V1::ResourceUpdateRequest.new()

      req.resource = Plumbing::convert_resource_to_plumbing(resource)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Resources.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.resource = Plumbing::convert_resource_to_porcelain(plumbing_response.resource)
      resp
    end

    # Delete removes a Resource by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::ResourceDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Resources.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Resources matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ResourceListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Resources.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.resources.each do |plumbing_item|
            g.yield Plumbing::convert_resource_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end

    # Healthcheck triggers a remote healthcheck. It may take minutes to propagate across a
    # large network of Nodes. The call will return immediately, and the updated health of the
    # Resource can be retrieved via Get or List.
    def healthcheck(
      id,
      deadline: nil
    )
      req = V1::ResourceHealthcheckRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.healthcheck(req, metadata: @parent.get_metadata("Resources.Healthcheck", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceHealthcheckResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end
  end

  # SnapshotResources exposes the read only methods of the Resources
  # service for historical queries.
  class SnapshotResources
    extend Gem::Deprecate

    def initialize(resources)
      @resources = resources
    end

    # Get reads one Resource by ID.
    def get(
      id,
      deadline: nil
    )
      return @resources.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of Resources matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @resources.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # ResourcesHistory records all changes to the state of a Resource.
  #
  # See {ResourceHistory}.
  class ResourcesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ResourcesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of ResourceHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ResourceHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("ResourcesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_resource_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # RoleResources enumerates the resources to which roles have access.
  # The RoleResources service is read-only.
  #
  # See {RoleResource}.
  class RoleResources
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RoleResources::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of RoleResource records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RoleResourceListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RoleResources.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.role_resources.each do |plumbing_item|
            g.yield Plumbing::convert_role_resource_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotRoleResources exposes the read only methods of the RoleResources
  # service for historical queries.
  class SnapshotRoleResources
    extend Gem::Deprecate

    def initialize(role_resources)
      @role_resources = role_resources
    end

    # List gets a list of RoleResource records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @role_resources.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # RoleResourcesHistory records all changes to the state of a RoleResource.
  #
  # See {RoleResourceHistory}.
  class RoleResourcesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RoleResourcesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of RoleResourceHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RoleResourceHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RoleResourcesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_role_resource_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # A Role has a list of access rules which determine which Resources the members
  # of the Role have access to. An Account can be a member of multiple Roles via
  # AccountAttachments.
  #
  # See {Role}.
  class Roles
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Roles::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new Role.
    def create(
      role,
      deadline: nil
    )
      req = V1::RoleCreateRequest.new()

      req.role = Plumbing::convert_role_to_plumbing(role)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Roles.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.role = Plumbing::convert_role_to_porcelain(plumbing_response.role)
      resp
    end

    # Get reads one Role by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::RoleGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Roles.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.role = Plumbing::convert_role_to_porcelain(plumbing_response.role)
      resp
    end

    # Update replaces all the fields of a Role by ID.
    def update(
      role,
      deadline: nil
    )
      req = V1::RoleUpdateRequest.new()

      req.role = Plumbing::convert_role_to_plumbing(role)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Roles.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.role = Plumbing::convert_role_to_porcelain(plumbing_response.role)
      resp
    end

    # Delete removes a Role by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::RoleDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Roles.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Roles matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RoleListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Roles.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.roles.each do |plumbing_item|
            g.yield Plumbing::convert_role_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotRoles exposes the read only methods of the Roles
  # service for historical queries.
  class SnapshotRoles
    extend Gem::Deprecate

    def initialize(roles)
      @roles = roles
    end

    # Get reads one Role by ID.
    def get(
      id,
      deadline: nil
    )
      return @roles.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of Roles matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @roles.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # RolesHistory records all changes to the state of a Role.
  #
  # See {RoleHistory}.
  class RolesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RolesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of RoleHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RoleHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RolesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_role_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SecretStoreHealths exposes health states for secret stores.
  #
  # See {SecretStoreHealth}.
  class SecretStoreHealths
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::SecretStoreHealths::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List reports the health status of node to secret store pairs.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::SecretStoreHealthListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("SecretStoreHealths.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.secret_store_healths.each do |plumbing_item|
            g.yield Plumbing::convert_secret_store_health_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end

    # Healthcheck triggers a remote healthcheck request for a secret store. It may take minutes
    # to propagate across a large network of Nodes. The call will return immediately, and the
    # updated health of the Secret Store can be retrieved via List.
    def healthcheck(
      secret_store_id,
      deadline: nil
    )
      req = V1::SecretStoreHealthcheckRequest.new()

      req.secret_store_id = (secret_store_id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.healthcheck(req, metadata: @parent.get_metadata("SecretStoreHealths.Healthcheck", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreHealthcheckResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end
  end

  # SecretStores are servers where resource secrets (passwords, keys) are stored.
  #
  # See:
  # {ActiveDirectoryStore}
  # {AWSStore}
  # {AWSCertX509Store}
  # {AzureStore}
  # {CyberarkConjurStore}
  # {CyberarkPAMStore}
  # {CyberarkPAMExperimentalStore}
  # {DelineaStore}
  # {GCPStore}
  # {GCPCertX509Store}
  # {KeyfactorSSHStore}
  # {KeyfactorX509Store}
  # {VaultAppRoleStore}
  # {VaultAppRoleCertSSHStore}
  # {VaultAppRoleCertX509Store}
  # {VaultAWSEC2Store}
  # {VaultAWSIAMStore}
  # {VaultTLSStore}
  # {VaultTLSCertSSHStore}
  # {VaultTLSCertX509Store}
  # {VaultTokenStore}
  # {VaultTokenCertSSHStore}
  # {VaultTokenCertX509Store}
  class SecretStores
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::SecretStores::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    def create(
      secret_store,
      deadline: nil
    )
      req = V1::SecretStoreCreateRequest.new()

      req.secret_store = Plumbing::convert_secret_store_to_plumbing(secret_store)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("SecretStores.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_store = Plumbing::convert_secret_store_to_porcelain(plumbing_response.secret_store)
      resp
    end

    # Get reads one SecretStore by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::SecretStoreGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("SecretStores.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_store = Plumbing::convert_secret_store_to_porcelain(plumbing_response.secret_store)
      resp
    end

    # Update replaces all the fields of a SecretStore by ID.
    def update(
      secret_store,
      deadline: nil
    )
      req = V1::SecretStoreUpdateRequest.new()

      req.secret_store = Plumbing::convert_secret_store_to_plumbing(secret_store)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("SecretStores.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_store = Plumbing::convert_secret_store_to_porcelain(plumbing_response.secret_store)
      resp
    end

    # Delete removes a SecretStore by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::SecretStoreDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("SecretStores.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of SecretStores matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::SecretStoreListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("SecretStores.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.secret_stores.each do |plumbing_item|
            g.yield Plumbing::convert_secret_store_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotSecretStores exposes the read only methods of the SecretStores
  # service for historical queries.
  class SnapshotSecretStores
    extend Gem::Deprecate

    def initialize(secret_stores)
      @secret_stores = secret_stores
    end

    # Get reads one SecretStore by ID.
    def get(
      id,
      deadline: nil
    )
      return @secret_stores.get(
               id,
               deadline: deadline,
             )
    end

    # List gets a list of SecretStores matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @secret_stores.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # SecretStoresHistory records all changes to the state of a SecretStore.
  #
  # See {SecretStoreHistory}.
  class SecretStoresHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::SecretStoresHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of SecretStoreHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::SecretStoreHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("SecretStoresHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_secret_store_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # WorkflowApprovers is an account or a role with the ability to approve requests bound to a workflow.
  #
  # See {WorkflowApprover}.
  class WorkflowApprovers
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowApprovers::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create creates a new workflow approver
    def create(
      workflow_approver,
      deadline: nil
    )
      req = V1::WorkflowApproversCreateRequest.new()

      req.workflow_approver = Plumbing::convert_workflow_approver_to_plumbing(workflow_approver)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("WorkflowApprovers.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowApproversCreateResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow_approver = Plumbing::convert_workflow_approver_to_porcelain(plumbing_response.workflow_approver)
      resp
    end

    # Get reads one workflow approver by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::WorkflowApproverGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("WorkflowApprovers.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowApproverGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow_approver = Plumbing::convert_workflow_approver_to_porcelain(plumbing_response.workflow_approver)
      resp
    end

    # Delete deletes a workflow approver
    def delete(
      id,
      deadline: nil
    )
      req = V1::WorkflowApproversDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("WorkflowApprovers.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowApproversDeleteResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Lists existing workflow approvers.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowApproversListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowApprovers.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.workflow_approvers.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_approver_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotWorkflowApprovers exposes the read only methods of the WorkflowApprovers
  # service for historical queries.
  class SnapshotWorkflowApprovers
    extend Gem::Deprecate

    def initialize(workflow_approvers)
      @workflow_approvers = workflow_approvers
    end

    # Get reads one workflow approver by ID.
    def get(
      id,
      deadline: nil
    )
      return @workflow_approvers.get(
               id,
               deadline: deadline,
             )
    end

    # Lists existing workflow approvers.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @workflow_approvers.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # WorkflowApproversHistory provides records of all changes to the state of a WorkflowApprover.
  #
  # See {WorkflowApproverHistory}.
  class WorkflowApproversHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowApproversHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of WorkflowApproversHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowApproversHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowApproversHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_approver_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # WorkflowAssignments links a Resource to a Workflow. The assigned resources are those that a user can request
  # access to via the workflow.
  #
  # See {WorkflowAssignment}.
  class WorkflowAssignments
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowAssignments::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Lists existing workflow assignments.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowAssignmentsListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowAssignments.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.workflow_assignments.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_assignment_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotWorkflowAssignments exposes the read only methods of the WorkflowAssignments
  # service for historical queries.
  class SnapshotWorkflowAssignments
    extend Gem::Deprecate

    def initialize(workflow_assignments)
      @workflow_assignments = workflow_assignments
    end

    # Lists existing workflow assignments.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @workflow_assignments.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # WorkflowAssignmentsHistory provides records of all changes to the state of a WorkflowAssignment.
  #
  # See {WorkflowAssignmentHistory}.
  class WorkflowAssignmentsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowAssignmentsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of WorkflowAssignmentsHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowAssignmentsHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowAssignmentsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_assignment_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # WorkflowRole links a role to a workflow. The linked roles indicate which roles a user must be a part of
  # to request access to a resource via the workflow.
  #
  # See {WorkflowRole}.
  class WorkflowRoles
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowRoles::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create creates a new workflow role
    def create(
      workflow_role,
      deadline: nil
    )
      req = V1::WorkflowRolesCreateRequest.new()

      req.workflow_role = Plumbing::convert_workflow_role_to_plumbing(workflow_role)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("WorkflowRoles.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowRolesCreateResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow_role = Plumbing::convert_workflow_role_to_porcelain(plumbing_response.workflow_role)
      resp
    end

    # Get reads one workflow role by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::WorkflowRoleGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("WorkflowRoles.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowRoleGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow_role = Plumbing::convert_workflow_role_to_porcelain(plumbing_response.workflow_role)
      resp
    end

    # Delete deletes a workflow role
    def delete(
      id,
      deadline: nil
    )
      req = V1::WorkflowRolesDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("WorkflowRoles.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowRolesDeleteResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Lists existing workflow roles.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowRolesListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowRoles.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.workflow_role.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_role_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotWorkflowRoles exposes the read only methods of the WorkflowRoles
  # service for historical queries.
  class SnapshotWorkflowRoles
    extend Gem::Deprecate

    def initialize(workflow_roles)
      @workflow_roles = workflow_roles
    end

    # Get reads one workflow role by ID.
    def get(
      id,
      deadline: nil
    )
      return @workflow_roles.get(
               id,
               deadline: deadline,
             )
    end

    # Lists existing workflow roles.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @workflow_roles.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # WorkflowRolesHistory provides records of all changes to the state of a WorkflowRole
  #
  # See {WorkflowRoleHistory}.
  class WorkflowRolesHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowRolesHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of WorkflowRolesHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowRolesHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowRolesHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_role_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # Workflows are the collection of rules that define the resources to which access can be requested,
  # the users that can request that access, and the mechanism for approving those requests which can either
  # be automatic approval or a set of users authorized to approve the requests.
  #
  # See {Workflow}.
  class Workflows
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Workflows::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create creates a new workflow and requires a name for the workflow.
    def create(
      workflow,
      deadline: nil
    )
      req = V1::WorkflowCreateRequest.new()

      req.workflow = Plumbing::convert_workflow_to_plumbing(workflow)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Workflows.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowCreateResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow = Plumbing::convert_workflow_to_porcelain(plumbing_response.workflow)
      resp
    end

    # Get reads one workflow by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::WorkflowGetRequest.new()
      if not @parent.snapshot_time.nil?
        req.meta = V1::GetRequestMetadata.new()
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Workflows.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow = Plumbing::convert_workflow_to_porcelain(plumbing_response.workflow)
      resp
    end

    # Delete deletes an existing workflow.
    def delete(
      id,
      deadline: nil
    )
      req = V1::WorkflowDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Workflows.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowDeleteResponse.new()
      resp.id = (plumbing_response.id)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Update updates an existing workflow.
    def update(
      workflow,
      deadline: nil
    )
      req = V1::WorkflowUpdateRequest.new()

      req.workflow = Plumbing::convert_workflow_to_plumbing(workflow)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Workflows.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = WorkflowUpdateResponse.new()
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.workflow = Plumbing::convert_workflow_to_porcelain(plumbing_response.workflow)
      resp
    end

    # Lists existing workflows.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Workflows.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.workflows.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SnapshotWorkflows exposes the read only methods of the Workflows
  # service for historical queries.
  class SnapshotWorkflows
    extend Gem::Deprecate

    def initialize(workflows)
      @workflows = workflows
    end

    # Get reads one workflow by ID.
    def get(
      id,
      deadline: nil
    )
      return @workflows.get(
               id,
               deadline: deadline,
             )
    end

    # Lists existing workflows.
    def list(
      filter,
      *args,
      deadline: nil
    )
      return @workflows.list(
               filter,
                            *args,
                            deadline: deadline,
             )
    end
  end

  # WorkflowsHistory provides records of all changes to the state of a Workflow.
  #
  # See {WorkflowHistory}.
  class WorkflowsHistory
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::WorkflowsHistory::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # List gets a list of WorkflowHistory records matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::WorkflowHistoryListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      if @parent.page_limit > 0
        req.meta.limit = @parent.page_limit
      end
      if not @parent.snapshot_time.nil?
        req.meta.snapshot_at = @parent.snapshot_time
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("WorkflowsHistory.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.history.each do |plumbing_item|
            g.yield Plumbing::convert_workflow_history_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end
end
