# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal This file was generated by protogen. DO NOT EDIT.

this_dir = File.expand_path(File.dirname(__FILE__))
lib_dir = File.join(this_dir, "grpc")
$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)
require "grpc"
require "enumerator"
Dir[File.join(__dir__, "grpc", "*.rb")].each { |file| require file }
Dir[File.join(__dir__, "models", "*.rb")].each { |file| require file }

module SDM #:nodoc:
  # AccountAttachments assign an account to a role.
  #
  # See {AccountAttachment}.
  class AccountAttachments
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountAttachments::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new AccountAttachment.
    def create(
      account_attachment,
      deadline: nil
    )
      req = V1::AccountAttachmentCreateRequest.new()

      req.account_attachment = Plumbing::convert_account_attachment_to_plumbing(account_attachment)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("AccountAttachments.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountAttachmentCreateResponse.new()
      resp.account_attachment = Plumbing::convert_account_attachment_to_porcelain(plumbing_response.account_attachment)
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one AccountAttachment by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::AccountAttachmentGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("AccountAttachments.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountAttachmentGetResponse.new()
      resp.account_attachment = Plumbing::convert_account_attachment_to_porcelain(plumbing_response.account_attachment)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a AccountAttachment by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::AccountAttachmentDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("AccountAttachments.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountAttachmentDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of AccountAttachments matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountAttachmentListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountAttachments.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.account_attachments.each do |plumbing_item|
            g.yield Plumbing::convert_account_attachment_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # AccountGrants assign a resource directly to an account, giving the account the permission to connect to that resource.
  #
  # See {AccountGrant}.
  class AccountGrants
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::AccountGrants::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new AccountGrant.
    def create(
      account_grant,
      deadline: nil
    )
      req = V1::AccountGrantCreateRequest.new()

      req.account_grant = Plumbing::convert_account_grant_to_plumbing(account_grant)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("AccountGrants.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGrantCreateResponse.new()
      resp.account_grant = Plumbing::convert_account_grant_to_porcelain(plumbing_response.account_grant)
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Get reads one AccountGrant by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::AccountGrantGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("AccountGrants.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGrantGetResponse.new()
      resp.account_grant = Plumbing::convert_account_grant_to_porcelain(plumbing_response.account_grant)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a AccountGrant by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::AccountGrantDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("AccountGrants.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGrantDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of AccountGrants matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountGrantListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("AccountGrants.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.account_grants.each do |plumbing_item|
            g.yield Plumbing::convert_account_grant_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # Accounts are users that have access to strongDM. There are two types of accounts:
  # 1. **Users:** humans who are authenticated through username and password or SSO.
  # 2. **Service Accounts:** machines that are authenticated using a service token.
  #
  # See:
  # {Service}
  # {User}
  class Accounts
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Accounts::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new Account.
    def create(
      account,
      deadline: nil
    )
      req = V1::AccountCreateRequest.new()

      req.account = Plumbing::convert_account_to_plumbing(account)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Accounts.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountCreateResponse.new()
      resp.account = Plumbing::convert_account_to_porcelain(plumbing_response.account)
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.token = (plumbing_response.token)
      resp
    end

    # Get reads one Account by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::AccountGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Accounts.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountGetResponse.new()
      resp.account = Plumbing::convert_account_to_porcelain(plumbing_response.account)
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Update replaces all the fields of an Account by ID.
    def update(
      account,
      deadline: nil
    )
      req = V1::AccountUpdateRequest.new()

      req.account = Plumbing::convert_account_to_plumbing(account)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Accounts.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountUpdateResponse.new()
      resp.account = Plumbing::convert_account_to_porcelain(plumbing_response.account)
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes an Account by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::AccountDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Accounts.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = AccountDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Accounts matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::AccountListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Accounts.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.accounts.each do |plumbing_item|
            g.yield Plumbing::convert_account_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # ControlPanel contains all administrative controls.
  class ControlPanel
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::ControlPanel::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # GetSSHCAPublicKey retrieves the SSH CA public key.
    def get_sshca_public_key(
      deadline: nil
    )
      req = V1::ControlPanelGetSSHCAPublicKeyRequest.new()

      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get_sshca_public_key(req, metadata: @parent.get_metadata("ControlPanel.GetSSHCAPublicKey", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ControlPanelGetSSHCAPublicKeyResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.public_key = (plumbing_response.public_key)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # VerifyJWT reports whether the given JWT token (x-sdm-token) is valid.
    def verify_jwt(
      token,
      deadline: nil
    )
      req = V1::ControlPanelVerifyJWTRequest.new()

      req.token = (token)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.verify_jwt(req, metadata: @parent.get_metadata("ControlPanel.VerifyJWT", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ControlPanelVerifyJWTResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.valid = (plumbing_response.valid)
      resp
    end
  end

  # Nodes make up the strongDM network, and allow your users to connect securely to your resources. There are two types of nodes:
  # - **Gateways** are the entry points into network. They listen for connection from the strongDM client, and provide access to databases and servers.
  # - **Relays** are used to extend the strongDM network into segmented subnets. They provide access to databases and servers but do not listen for incoming connections.
  #
  # See:
  # {Gateway}
  # {Relay}
  class Nodes
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Nodes::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new Node.
    def create(
      node,
      deadline: nil
    )
      req = V1::NodeCreateRequest.new()

      req.node = Plumbing::convert_node_to_plumbing(node)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Nodes.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.node = Plumbing::convert_node_to_porcelain(plumbing_response.node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.token = (plumbing_response.token)
      resp
    end

    # Get reads one Node by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::NodeGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Nodes.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.node = Plumbing::convert_node_to_porcelain(plumbing_response.node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Update replaces all the fields of a Node by ID.
    def update(
      node,
      deadline: nil
    )
      req = V1::NodeUpdateRequest.new()

      req.node = Plumbing::convert_node_to_plumbing(node)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Nodes.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.node = Plumbing::convert_node_to_porcelain(plumbing_response.node)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # Delete removes a Node by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::NodeDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Nodes.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = NodeDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Nodes matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::NodeListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Nodes.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.nodes.each do |plumbing_item|
            g.yield Plumbing::convert_node_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # RemoteIdentities assign a resource directly to an account, giving the account the permission to connect to that resource.
  #
  # See {RemoteIdentity}.
  class RemoteIdentities
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RemoteIdentities::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new RemoteIdentity.
    def create(
      remote_identity,
      deadline: nil
    )
      req = V1::RemoteIdentityCreateRequest.new()

      req.remote_identity = Plumbing::convert_remote_identity_to_plumbing(remote_identity)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("RemoteIdentities.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity = Plumbing::convert_remote_identity_to_porcelain(plumbing_response.remote_identity)
      resp
    end

    # Get reads one RemoteIdentity by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::RemoteIdentityGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("RemoteIdentities.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity = Plumbing::convert_remote_identity_to_porcelain(plumbing_response.remote_identity)
      resp
    end

    # Update replaces all the fields of a RemoteIdentity by ID.
    def update(
      remote_identity,
      deadline: nil
    )
      req = V1::RemoteIdentityUpdateRequest.new()

      req.remote_identity = Plumbing::convert_remote_identity_to_plumbing(remote_identity)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("RemoteIdentities.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity = Plumbing::convert_remote_identity_to_porcelain(plumbing_response.remote_identity)
      resp
    end

    # Delete removes a RemoteIdentity by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::RemoteIdentityDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("RemoteIdentities.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of RemoteIdentities matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RemoteIdentityListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RemoteIdentities.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.remote_identities.each do |plumbing_item|
            g.yield Plumbing::convert_remote_identity_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts.
  # An Account's relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
  #
  # See {RemoteIdentityGroup}.
  class RemoteIdentityGroups
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::RemoteIdentityGroups::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Get reads one RemoteIdentityGroup by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::RemoteIdentityGroupGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("RemoteIdentityGroups.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RemoteIdentityGroupGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.remote_identity_group = Plumbing::convert_remote_identity_group_to_porcelain(plumbing_response.remote_identity_group)
      resp
    end

    # List gets a list of RemoteIdentityGroups matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RemoteIdentityGroupListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("RemoteIdentityGroups.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.remote_identity_groups.each do |plumbing_item|
            g.yield Plumbing::convert_remote_identity_group_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # Resources are databases, servers, clusters, websites, or clouds that strongDM
  # delegates access to.
  #
  # See:
  # {AKS}
  # {AKSBasicAuth}
  # {AKSServiceAccount}
  # {AKSServiceAccountUserImpersonation}
  # {AKSUserImpersonation}
  # {AmazonEKS}
  # {AmazonEKSUserImpersonation}
  # {AmazonES}
  # {AmazonMQAMQP091}
  # {Athena}
  # {AuroraMysql}
  # {AuroraPostgres}
  # {AWS}
  # {AWSConsole}
  # {AWSConsoleStaticKeyPair}
  # {Azure}
  # {AzureCertificate}
  # {AzureMysql}
  # {AzurePostgres}
  # {BigQuery}
  # {Cassandra}
  # {Citus}
  # {Clustrix}
  # {Cockroach}
  # {DB2I}
  # {DB2LUW}
  # {DocumentDBHost}
  # {DocumentDBReplicaSet}
  # {Druid}
  # {DynamoDB}
  # {Elastic}
  # {ElasticacheRedis}
  # {GCP}
  # {GoogleGKE}
  # {GoogleGKEUserImpersonation}
  # {Greenplum}
  # {HTTPAuth}
  # {HTTPBasicAuth}
  # {HTTPNoAuth}
  # {Kubernetes}
  # {KubernetesBasicAuth}
  # {KubernetesServiceAccount}
  # {KubernetesServiceAccountUserImpersonation}
  # {KubernetesUserImpersonation}
  # {Maria}
  # {Memcached}
  # {Memsql}
  # {MongoHost}
  # {MongoLegacyHost}
  # {MongoLegacyReplicaset}
  # {MongoReplicaSet}
  # {MongoShardedCluster}
  # {MTLSMysql}
  # {MTLSPostgres}
  # {Mysql}
  # {Neptune}
  # {NeptuneIAM}
  # {Oracle}
  # {Postgres}
  # {Presto}
  # {RabbitMQAMQP091}
  # {RawTCP}
  # {RDP}
  # {Redis}
  # {Redshift}
  # {SingleStore}
  # {Snowflake}
  # {Snowsight}
  # {SQLServer}
  # {SSH}
  # {SSHCert}
  # {SSHCustomerKey}
  # {Sybase}
  # {SybaseIQ}
  # {Teradata}
  class Resources
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Resources::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # EnumerateTags gets a list of the filter matching tags.
    def enumerate_tags(
      filter,
      *args,
      deadline: nil
    )
      req = V1::EnumerateTagsRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.enumerate_tags(req, metadata: @parent.get_metadata("Resources.EnumerateTags", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.matches.each do |plumbing_item|
            g.yield Plumbing::convert_tag_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end

    # Create registers a new Resource.
    def create(
      resource,
      deadline: nil
    )
      req = V1::ResourceCreateRequest.new()

      req.resource = Plumbing::convert_resource_to_plumbing(resource)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Resources.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.resource = Plumbing::convert_resource_to_porcelain(plumbing_response.resource)
      resp
    end

    # Get reads one Resource by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::ResourceGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Resources.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.resource = Plumbing::convert_resource_to_porcelain(plumbing_response.resource)
      resp
    end

    # Update replaces all the fields of a Resource by ID.
    def update(
      resource,
      deadline: nil
    )
      req = V1::ResourceUpdateRequest.new()

      req.resource = Plumbing::convert_resource_to_plumbing(resource)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Resources.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.resource = Plumbing::convert_resource_to_porcelain(plumbing_response.resource)
      resp
    end

    # Delete removes a Resource by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::ResourceDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Resources.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = ResourceDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Resources matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::ResourceListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Resources.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.resources.each do |plumbing_item|
            g.yield Plumbing::convert_resource_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # A Role has a list of access rules which determine which Resources the members
  # of the Role have access to. An Account can be a member of multiple Roles via
  # AccountAttachments.
  #
  # See {Role}.
  class Roles
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::Roles::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    # Create registers a new Role.
    def create(
      role,
      deadline: nil
    )
      req = V1::RoleCreateRequest.new()

      req.role = Plumbing::convert_role_to_plumbing(role)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("Roles.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.role = Plumbing::convert_role_to_porcelain(plumbing_response.role)
      resp
    end

    # Get reads one Role by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::RoleGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("Roles.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.role = Plumbing::convert_role_to_porcelain(plumbing_response.role)
      resp
    end

    # Update replaces all the fields of a Role by ID.
    def update(
      role,
      deadline: nil
    )
      req = V1::RoleUpdateRequest.new()

      req.role = Plumbing::convert_role_to_plumbing(role)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("Roles.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.role = Plumbing::convert_role_to_porcelain(plumbing_response.role)
      resp
    end

    # Delete removes a Role by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::RoleDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("Roles.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = RoleDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of Roles matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::RoleListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("Roles.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.roles.each do |plumbing_item|
            g.yield Plumbing::convert_role_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end

  # SecretStores are servers where resource secrets (passwords, keys) are stored.
  #
  # See:
  # {AWSStore}
  # {AzureStore}
  # {CyberarkConjurStore}
  # {CyberarkPAMExperimentalStore}
  # {DelineaStore}
  # {GCPStore}
  # {VaultAppRoleStore}
  # {VaultTLSStore}
  # {VaultTokenStore}
  class SecretStores
    extend Gem::Deprecate

    def initialize(channel, parent)
      begin
        @stub = V1::SecretStores::Stub.new(nil, nil, channel_override: channel)
      rescue => exception
        raise Plumbing::convert_error_to_porcelain(exception)
      end
      @parent = parent
    end

    def create(
      secret_store,
      deadline: nil
    )
      req = V1::SecretStoreCreateRequest.new()

      req.secret_store = Plumbing::convert_secret_store_to_plumbing(secret_store)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.create(req, metadata: @parent.get_metadata("SecretStores.Create", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreCreateResponse.new()
      resp.meta = Plumbing::convert_create_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_store = Plumbing::convert_secret_store_to_porcelain(plumbing_response.secret_store)
      resp
    end

    # Get reads one SecretStore by ID.
    def get(
      id,
      deadline: nil
    )
      req = V1::SecretStoreGetRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.get(req, metadata: @parent.get_metadata("SecretStores.Get", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreGetResponse.new()
      resp.meta = Plumbing::convert_get_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_store = Plumbing::convert_secret_store_to_porcelain(plumbing_response.secret_store)
      resp
    end

    # Update replaces all the fields of a SecretStore by ID.
    def update(
      secret_store,
      deadline: nil
    )
      req = V1::SecretStoreUpdateRequest.new()

      req.secret_store = Plumbing::convert_secret_store_to_plumbing(secret_store)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.update(req, metadata: @parent.get_metadata("SecretStores.Update", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreUpdateResponse.new()
      resp.meta = Plumbing::convert_update_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp.secret_store = Plumbing::convert_secret_store_to_porcelain(plumbing_response.secret_store)
      resp
    end

    # Delete removes a SecretStore by ID.
    def delete(
      id,
      deadline: nil
    )
      req = V1::SecretStoreDeleteRequest.new()

      req.id = (id)
      tries = 0
      plumbing_response = nil
      loop do
        begin
          plumbing_response = @stub.delete(req, metadata: @parent.get_metadata("SecretStores.Delete", req), deadline: deadline)
        rescue => exception
          if (@parent.shouldRetry(tries, exception))
            tries + +@parent.jitterSleep(tries)
            next
          end
          raise Plumbing::convert_error_to_porcelain(exception)
        end
        break
      end

      resp = SecretStoreDeleteResponse.new()
      resp.meta = Plumbing::convert_delete_response_metadata_to_porcelain(plumbing_response.meta)
      resp.rate_limit = Plumbing::convert_rate_limit_metadata_to_porcelain(plumbing_response.rate_limit)
      resp
    end

    # List gets a list of SecretStores matching a given set of criteria.
    def list(
      filter,
      *args,
      deadline: nil
    )
      req = V1::SecretStoreListRequest.new()
      req.meta = V1::ListRequestMetadata.new()
      page_size_option = @parent._test_options["PageSize"]
      if page_size_option.is_a? Integer
        req.meta.limit = page_size_option
      end

      req.filter = Plumbing::quote_filter_args(filter, *args)
      resp = Enumerator::Generator.new { |g|
        tries = 0
        loop do
          begin
            plumbing_response = @stub.list(req, metadata: @parent.get_metadata("SecretStores.List", req), deadline: deadline)
          rescue => exception
            if (@parent.shouldRetry(tries, exception))
              tries + +@parent.jitterSleep(tries)
              next
            end
            raise Plumbing::convert_error_to_porcelain(exception)
          end
          tries = 0
          plumbing_response.secret_stores.each do |plumbing_item|
            g.yield Plumbing::convert_secret_store_to_porcelain(plumbing_item)
          end
          break if plumbing_response.meta.next_cursor == ""
          req.meta.cursor = plumbing_response.meta.next_cursor
        end
      }
      resp
    end
  end
end
