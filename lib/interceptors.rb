# Copyright 2020 StrongDM Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# @internal Code generated by protogen. DO NOT EDIT.

require "openssl"
require_relative "./grpc/plumbing"

module SDM
  # MethodInterceptor provides a generic hook system for modifying
  # requests and responses before/after gRPC calls
  class MethodInterceptor
    def initialize(client)
      @client = client
      @before_hooks = {}
      @after_hooks = {}
    end

    # Register a hook to run before a method call
    # method_name: "ServiceName.MethodName" (e.g., "ManagedSecrets.Create")
    # block: receives (service_instance, request) and should return modified request
    def before(method_name, &block)
      @before_hooks[method_name] = block
    end

    # Register a hook to run after a method call
    # method_name: "ServiceName.MethodName"
    # block: receives (service_instance, request, response) and should return modified response
    def after(method_name, &block)
      @after_hooks[method_name] = block
    end

    # Execute before hooks for a method
    def execute_before(method_name, service_instance, request)
      hook = @before_hooks[method_name]
      return request unless hook
      hook.call(service_instance, request)
    end

    # Execute after hooks for a method
    def execute_after(method_name, service_instance, request, response)
      hook = @after_hooks[method_name]
      return response unless hook
      hook.call(service_instance, request, response)
    end
  end

  # SecretEncryptionInterceptor implements encryption for managed secrets
  class SecretEncryptionInterceptor
    def initialize(client)
      @client = client
      @public_key_cache = {}
      @private_key = nil
    end

    # Lazy-load private key for retrievals
    def private_key
      @private_key ||= OpenSSL::PKey::RSA.new(4096)
    end

    # Cache a secret engine's public key
    def cache_public_key(engine_id, public_key_pem)
      return if public_key_pem.nil? || public_key_pem.empty?
      @public_key_cache[engine_id] = OpenSSL::PKey::RSA.new(public_key_pem)
    end

    # Get cached public key
    def get_public_key(engine_id)
      @public_key_cache[engine_id]
    end

    # Encrypt data using RSA-OAEP with SHA256
    def encrypt(public_key, plaintext)
      return plaintext if plaintext.nil? || plaintext.empty?
      public_key.encrypt(plaintext, rsa_padding_mode: "oaep", rsa_oaep_md: "sha256", rsa_mgf1_md: "sha256")
    end

    # Decrypt data using RSA-OAEP with SHA256
    def decrypt(ciphertext)
      return ciphertext if ciphertext.nil? || ciphertext.empty?
      private_key.decrypt(ciphertext, rsa_padding_mode: "oaep", rsa_oaep_md: "sha256", rsa_mgf1_md: "sha256")
    end

    # Export public key in PEM format
    def export_public_key
      private_key.public_key.to_pem
    end

    # Setup hooks on the interceptor
    def setup(interceptor)
      setup_managed_secrets_hooks(interceptor)
      setup_secret_engines_hooks(interceptor)
    end

    private

    def setup_managed_secrets_hooks(interceptor)
      # Hook for ManagedSecrets.Create - encrypt before sending
      interceptor.before("ManagedSecrets.Create") do |service, req|
        secret = req.managed_secret
        if secret && !secret.value.nil? && !secret.value.empty? && !secret.secret_engine_id.nil?
          # Try to get public key from cache or fetch it
          pub_key = get_public_key(secret.secret_engine_id)
          if pub_key.nil?
            begin
              @client.secret_engines.get(secret.secret_engine_id)
              pub_key = get_public_key(secret.secret_engine_id)
            rescue
              # If fetch fails, let server handle it
            end
          end

          # Encrypt if we have the key
          if pub_key
            secret.value = encrypt(pub_key, secret.value)
          end
        end
        req
      end

      # Hook for ManagedSecrets.Update - encrypt before sending
      interceptor.before("ManagedSecrets.Update") do |service, req|
        secret = req.managed_secret
        if secret && !secret.value.nil? && !secret.value.empty? && !secret.secret_engine_id.nil?
          pub_key = get_public_key(secret.secret_engine_id)
          if pub_key.nil?
            begin
              @client.secret_engines.get(secret.secret_engine_id)
              pub_key = get_public_key(secret.secret_engine_id)
            rescue
              # If fetch fails, let server handle it
            end
          end

          if pub_key
            secret.value = encrypt(pub_key, secret.value)
          end
        end
        req
      end

      # Hook for ManagedSecrets.Retrieve - add public key and decrypt response
      interceptor.before("ManagedSecrets.Retrieve") do |service, req|
        if req.public_key.nil? || req.public_key.empty?
          req.public_key = export_public_key
        end
        req
      end

      interceptor.after("ManagedSecrets.Retrieve") do |service, req, resp|
        # Only decrypt if we provided the public key
        if req.public_key == export_public_key
          secret = resp.managed_secret
          if secret && !secret.value.nil? && !secret.value.empty?
            secret.value = decrypt(secret.value)
          end
        end
        resp
      end
    end

    def setup_secret_engines_hooks(interceptor)
      # Hook for SecretEngines.Get - cache public key after response
      interceptor.after("SecretEngines.Get") do |service, req, resp|
        engine = Plumbing::convert_secret_engine_to_porcelain(resp.secret_engine)
        if engine && !engine.id.nil? && !engine.public_key.nil?
          cache_public_key(engine.id, engine.public_key)
        end
        resp
      end
    end
  end

  # EnumeratorInterceptor provides utilities for wrapping enumerators with hooks
  module EnumeratorInterceptor
    # Wraps an enumerator to cache secret engine public keys
    def self.wrap_secret_engine_list(enumerator, encryption_interceptor)
      Enumerator.new do |yielder|
        enumerator.each do |engine|
          if engine && !engine.id.nil? && !engine.public_key.nil?
            encryption_interceptor.cache_public_key(engine.id, engine.public_key)
          end
          yielder << engine
        end
      end
    end
  end
end
